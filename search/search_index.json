{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Embedded Programs Technical Tutorials Story of a Boot Loader What makes a real RTOS? Spin Locks in Linux Journey of Interrupt Technical Questions Linux Kernel Questions System Programming Questions Future Reading C Interview Questions (Vijay Networks) Best Interview Questions for Embedded Programmers (Sanjay Ahuja)","title":"Embedded Programs"},{"location":"#embedded-programs","text":"","title":"Embedded Programs"},{"location":"#technical-tutorials","text":"Story of a Boot Loader What makes a real RTOS? Spin Locks in Linux Journey of Interrupt","title":"Technical Tutorials"},{"location":"#technical-questions","text":"Linux Kernel Questions System Programming Questions","title":"Technical Questions"},{"location":"#future-reading","text":"C Interview Questions (Vijay Networks) Best Interview Questions for Embedded Programmers (Sanjay Ahuja)","title":"Future Reading"},{"location":"data-structure/","text":"Data Structure Basic Hello World Calculate Factorail of a number Swap two numbers without temp variable Draw diamond pattern on screen Reverse digits in number Find Endianess of Machine Arrays Arrays Bitfields Set multiple bits in number Reverse bits in number Strings String Length String Copy Program Reverse String Remove leading & trailing white space from a string Linked List Implementation of Linked List Stack Stack operations Implementation of Stack using Linked-list Infix to Prefix conversion using Stack with Linklist Queue Queue implementation using array Binary Tree Binary Tree Binary Tree without recursion [What makes a real RTOS?] Named Pipe Read & Write Named Pipe IPC Pipe IPC Pipes Implementation Message Queue Message Queue Implementation","title":"Data Structure"},{"location":"data-structure/#data-structure","text":"","title":"Data Structure"},{"location":"data-structure/#basic","text":"Hello World Calculate Factorail of a number Swap two numbers without temp variable Draw diamond pattern on screen Reverse digits in number Find Endianess of Machine","title":"Basic"},{"location":"data-structure/#arrays","text":"Arrays","title":"Arrays"},{"location":"data-structure/#bitfields","text":"Set multiple bits in number Reverse bits in number","title":"Bitfields"},{"location":"data-structure/#strings","text":"String Length String Copy Program Reverse String Remove leading & trailing white space from a string","title":"Strings"},{"location":"data-structure/#linked-list","text":"Implementation of Linked List","title":"Linked List"},{"location":"data-structure/#stack","text":"Stack operations Implementation of Stack using Linked-list Infix to Prefix conversion using Stack with Linklist","title":"Stack"},{"location":"data-structure/#queue","text":"Queue implementation using array","title":"Queue"},{"location":"data-structure/#binary-tree","text":"Binary Tree Binary Tree without recursion [What makes a real RTOS?]","title":"Binary Tree"},{"location":"data-structure/#named-pipe","text":"Read & Write Named Pipe","title":"Named Pipe"},{"location":"data-structure/#ipc-pipe","text":"IPC Pipes Implementation","title":"IPC Pipe"},{"location":"data-structure/#message-queue","text":"Message Queue Implementation","title":"Message Queue"},{"location":"data-structure/binary-tree-without-recursion/","text":"Binary Tree without Recursion OCTOBER 17, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> struct node { char data; struct node *left; struct node *right; }; void print_tree(struct node *p) { struct node *t=p; if ( t != NULL ) { print_tree(t->left); printf(\"%c \",t->data); print_tree(t->right); } } void build_tree(struct node **t, char *data, int count) { struct node *ptr[10]; int i; for (i=0;i<count;i++) { ptr[i]=malloc(sizeof(struct node)); ptr[i]->data = data[i]; ptr[i]->left = ptr[i]->right = NULL; } for (i=0; i<count;i++) { /* update left child */ if ((2*i+1) < count ) { ptr[i]->left = ptr[2*i+1]; } /* update right child */ if ((2*i+2) < count ) ptr[i]->right = ptr[2*i+2]; } (*t) = ptr[0]; } void main() { /* tree representation in array form * left subtree = 2*(index) + 1; * right subtree = 2*(index) + 2; */ char data[] = { 'A','B','C','D','E','F','G','H','I','J'}; /* pictorial view of above tree */ /* (A) */ /* / \\ */ /* / \\ */ /* / \\ */ /* / \\ */ /* / */ /* (B) (C) */ /* / / */ /* / / */ /* / / */ /* / / */ /* / / */ /* (D) (E) (F) (G) */ /* / \\ / */ /* / / */ /* / / */ /* (H) (I) (J) */ struct node *btree=NULL; build_tree(&btree, data,(int)sizeof(data)/sizeof(data[0])); printf(\"nElement of the tree are:n\"); print_tree(btree); }","title":"Binary tree without recursion"},{"location":"data-structure/binary-tree-without-recursion/#binary-tree-without-recursion","text":"OCTOBER 17, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> struct node { char data; struct node *left; struct node *right; }; void print_tree(struct node *p) { struct node *t=p; if ( t != NULL ) { print_tree(t->left); printf(\"%c \",t->data); print_tree(t->right); } } void build_tree(struct node **t, char *data, int count) { struct node *ptr[10]; int i; for (i=0;i<count;i++) { ptr[i]=malloc(sizeof(struct node)); ptr[i]->data = data[i]; ptr[i]->left = ptr[i]->right = NULL; } for (i=0; i<count;i++) { /* update left child */ if ((2*i+1) < count ) { ptr[i]->left = ptr[2*i+1]; } /* update right child */ if ((2*i+2) < count ) ptr[i]->right = ptr[2*i+2]; } (*t) = ptr[0]; } void main() { /* tree representation in array form * left subtree = 2*(index) + 1; * right subtree = 2*(index) + 2; */ char data[] = { 'A','B','C','D','E','F','G','H','I','J'}; /* pictorial view of above tree */ /* (A) */ /* / \\ */ /* / \\ */ /* / \\ */ /* / \\ */ /* / */ /* (B) (C) */ /* / / */ /* / / */ /* / / */ /* / / */ /* / / */ /* (D) (E) (F) (G) */ /* / \\ / */ /* / / */ /* / / */ /* (H) (I) (J) */ struct node *btree=NULL; build_tree(&btree, data,(int)sizeof(data)/sizeof(data[0])); printf(\"nElement of the tree are:n\"); print_tree(btree); }","title":"Binary Tree without Recursion"},{"location":"data-structure/binary-tree/","text":"Program for Binary Tree FEBRUARY 24, 2019 \\~ SUNIL KUMAR #include<stdio.h> #include<stdlib.h> struct node { int data; int height; struct node *left; struct node *right; }; void insert(struct node **btree, int data) { if (*btree == NULL) { (*btree) = malloc(sizeof(struct node)); (*btree)->data = data; (*btree)->left = (*btree)->right = NULL; } else { if (data > (*btree)->data) { insert(&((*btree)->right), data); } else { insert(&((*btree)->left), data); } } } struct node *xsucc(struct node *temp) { temp = temp->right; while (temp->left != NULL) { temp = temp->left; } return temp; } struct node *delete(struct node *xnode, int data) { if (xnode == NULL) return NULL; if (data < xnode->data) { xnode->left = delete(xnode->left, data); } else if (data > xnode->data) { xnode->right = delete(xnode->right, data); } else { if ((xnode->left == NULL) && (xnode->right != NULL)) { printf(\"Found the node %d (Right)\\n\", xnode->data); struct node *temp = xnode->right; free(xnode); return temp; } else if ((xnode->left != NULL) && (xnode->right == NULL)) { printf(\"Found the node %d (Left)\\n\", xnode->data); struct node *temp = xnode->left; free(xnode); return temp; } else if ((xnode->left == NULL) && (xnode->right == NULL)) { free(xnode); return NULL; } else if ((xnode->left != NULL) && (xnode->right != NULL)) { struct node *temp = xsucc(xnode); printf(\"Found the xsucc node %d\\n\", temp->data); xnode->data = temp->data; xnode->right = delete(xnode->right, temp->data); } else { printf(\"BUG: Found the node %d\\n\", xnode->data); } } return xnode; } void inorder(struct node *btree) { if (btree == NULL) return; inorder(btree->left); printf(\"%d \", btree->data); inorder(btree->right); } int height(struct node *xnode) { int lheight = 0, rheight = 0, ht = 0; if (xnode == NULL) return 0; lheight = height(xnode->left); rheight = height(xnode->right); if (lheight > rheight) { ht = lheight + 1; } else { ht = rheight + 1; } return ht; } void levelorder(struct node *btree) { struct node *temp[20] = { NULL }; int i = 0, c = 0; if (btree == NULL) return; temp[0] = btree; while (temp[c] != NULL) { printf(\"%d \", temp[c]->data); if (temp[c]->left != NULL) { temp[i + 1] = temp[c]->left; i++; } if (temp[c]->right != NULL) { temp[i + 1] = temp[c]->right; i++; } c++; } } void main() { struct node *bst = NULL; int values[] = { 34, 45, 22, 1, 79, 32, 90, 77, 3 }; int i, size; size = sizeof(values) / sizeof(values[0]); for (i = 0; i < size; i++) { insert(&bst, values[i]); } printf(\"In-order traversal of BST(%d):\\n\", size); inorder(bst); printf(\"\\n\"); printf(\"Level-order traversal of BST(%d):\\n\", size); levelorder(bst); printf(\"\\n\"); printf(\"Height of BST(%d): %d\\n\", size, height(bst->left)); //deleteNode(bst, 1); delete(bst, 22); size -= 1; printf(\"Level-order traversal of BST after deletion (%d):\\n\", size); levelorder(bst); printf(\"\\n\"); }","title":"Binary tree"},{"location":"data-structure/binary-tree/#program-for-binary-tree","text":"FEBRUARY 24, 2019 \\~ SUNIL KUMAR #include<stdio.h> #include<stdlib.h> struct node { int data; int height; struct node *left; struct node *right; }; void insert(struct node **btree, int data) { if (*btree == NULL) { (*btree) = malloc(sizeof(struct node)); (*btree)->data = data; (*btree)->left = (*btree)->right = NULL; } else { if (data > (*btree)->data) { insert(&((*btree)->right), data); } else { insert(&((*btree)->left), data); } } } struct node *xsucc(struct node *temp) { temp = temp->right; while (temp->left != NULL) { temp = temp->left; } return temp; } struct node *delete(struct node *xnode, int data) { if (xnode == NULL) return NULL; if (data < xnode->data) { xnode->left = delete(xnode->left, data); } else if (data > xnode->data) { xnode->right = delete(xnode->right, data); } else { if ((xnode->left == NULL) && (xnode->right != NULL)) { printf(\"Found the node %d (Right)\\n\", xnode->data); struct node *temp = xnode->right; free(xnode); return temp; } else if ((xnode->left != NULL) && (xnode->right == NULL)) { printf(\"Found the node %d (Left)\\n\", xnode->data); struct node *temp = xnode->left; free(xnode); return temp; } else if ((xnode->left == NULL) && (xnode->right == NULL)) { free(xnode); return NULL; } else if ((xnode->left != NULL) && (xnode->right != NULL)) { struct node *temp = xsucc(xnode); printf(\"Found the xsucc node %d\\n\", temp->data); xnode->data = temp->data; xnode->right = delete(xnode->right, temp->data); } else { printf(\"BUG: Found the node %d\\n\", xnode->data); } } return xnode; } void inorder(struct node *btree) { if (btree == NULL) return; inorder(btree->left); printf(\"%d \", btree->data); inorder(btree->right); } int height(struct node *xnode) { int lheight = 0, rheight = 0, ht = 0; if (xnode == NULL) return 0; lheight = height(xnode->left); rheight = height(xnode->right); if (lheight > rheight) { ht = lheight + 1; } else { ht = rheight + 1; } return ht; } void levelorder(struct node *btree) { struct node *temp[20] = { NULL }; int i = 0, c = 0; if (btree == NULL) return; temp[0] = btree; while (temp[c] != NULL) { printf(\"%d \", temp[c]->data); if (temp[c]->left != NULL) { temp[i + 1] = temp[c]->left; i++; } if (temp[c]->right != NULL) { temp[i + 1] = temp[c]->right; i++; } c++; } } void main() { struct node *bst = NULL; int values[] = { 34, 45, 22, 1, 79, 32, 90, 77, 3 }; int i, size; size = sizeof(values) / sizeof(values[0]); for (i = 0; i < size; i++) { insert(&bst, values[i]); } printf(\"In-order traversal of BST(%d):\\n\", size); inorder(bst); printf(\"\\n\"); printf(\"Level-order traversal of BST(%d):\\n\", size); levelorder(bst); printf(\"\\n\"); printf(\"Height of BST(%d): %d\\n\", size, height(bst->left)); //deleteNode(bst, 1); delete(bst, 22); size -= 1; printf(\"Level-order traversal of BST after deletion (%d):\\n\", size); levelorder(bst); printf(\"\\n\"); }","title":"Program for Binary Tree"},{"location":"data-structure/draw-diamond-pattern/","text":"Program to draw diamond pattern SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> int main() { int i,j, N=10; for(i=N;i>=1;i--) { for(j=1;j<=2*N;j++) { if ((j < i) || (j > (2*N-i))) printf(\" \"); else printf(\"*\"); } printf(\"n\"); } for(i=1;i<=N;i++) { for(j=1;j<=2*N;j++) { if ((j < i) || (j > (2*N-i))) printf(\" \"); else printf(\"*\"); } printf(\"n\"); } }","title":"Draw diamond pattern"},{"location":"data-structure/draw-diamond-pattern/#program-to-draw-diamond-pattern","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> int main() { int i,j, N=10; for(i=N;i>=1;i--) { for(j=1;j<=2*N;j++) { if ((j < i) || (j > (2*N-i))) printf(\" \"); else printf(\"*\"); } printf(\"n\"); } for(i=1;i<=N;i++) { for(j=1;j<=2*N;j++) { if ((j < i) || (j > (2*N-i))) printf(\" \"); else printf(\"*\"); } printf(\"n\"); } }","title":"Program to draw diamond pattern"},{"location":"data-structure/factorial/","text":"Program to find factorial of a given number SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: factorial.c */ #include <stdio.h> /* function to find factorial of number */ int fact(int n) { int i, f=1; if ( n > 1 ){ for (i=n; i !=1 ; i --) { f = f * i; } } return f; } /* main function */ int main () { int num=0; printf(\"Enter number to find factorial: \"); scanf (\"%d\", &num); printf(\"Factorial of %d is %dn\", num, fact(num)); return 0; } Compilation Steps: $ gcc -o factorial factorial.c Output: Enter number to find factorial: 7 Factorial of 7 is 5040","title":"Factorial"},{"location":"data-structure/factorial/#program-to-find-factorial-of-a-given-number","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: factorial.c */ #include <stdio.h> /* function to find factorial of number */ int fact(int n) { int i, f=1; if ( n > 1 ){ for (i=n; i !=1 ; i --) { f = f * i; } } return f; } /* main function */ int main () { int num=0; printf(\"Enter number to find factorial: \"); scanf (\"%d\", &num); printf(\"Factorial of %d is %dn\", num, fact(num)); return 0; }","title":"Program to find factorial of a given number"},{"location":"data-structure/factorial/#compilation-steps","text":"$ gcc -o factorial factorial.c","title":"Compilation Steps:"},{"location":"data-structure/factorial/#output","text":"Enter number to find factorial: 7 Factorial of 7 is 5040","title":"Output:"},{"location":"data-structure/hello-world/","text":"Program to Print \"Hello World\" SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file : hello.c */ /* Include headers */ #include <stdio.h> /* main function */ void main() { /* print hello world to console */ printf(\"Hello Worldn\"); } /* End of program */ Compilation Steps: $ gcc hello.c -o hello Output: $ ./hello Hello World","title":"Hello world"},{"location":"data-structure/hello-world/#program-to-print-hello-world","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file : hello.c */ /* Include headers */ #include <stdio.h> /* main function */ void main() { /* print hello world to console */ printf(\"Hello Worldn\"); } /* End of program */","title":"Program to Print \"Hello World\""},{"location":"data-structure/hello-world/#compilation-steps","text":"$ gcc hello.c -o hello","title":"Compilation Steps:"},{"location":"data-structure/hello-world/#output","text":"$ ./hello Hello World","title":"Output:"},{"location":"data-structure/infix-to-prefix-conversion-using-stack-with-linklist/","text":"Infix to Prefix conversion using Stack with Linklist OCTOBER 16, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #include <string.h> struct stack { char data; struct stack *next; }; void push(struct stack **top, char num) { struct stack *temp; temp=malloc(sizeof(struct stack)); if (temp == NULL) { printf(\"Stack is fulln\"); return; } temp->data = num; temp->next = NULL; if ((*top) == NULL) { (*top)=temp; } else { temp->next = (*top); (*top) = temp; } } char pop(struct stack **top) { struct stack *temp; char data; if ((*top) == NULL) { //printf(\"Stack is emptyn\"); return NULL; } temp = (*top); (*top)=(*top)->next; data = temp->data; free(temp); return(data); } char gettop(struct stack **top) { if ((*top) == NULL) { //printf(\"Stack is emptyn\"); return NULL; } return((*top)->data); } void display(struct stack *top) { struct stack *ptr = top; //ptr=top; printf(\"| TOP |n\"); while ( ptr != NULL ) { printf (\"| %c |n\",ptr->data); ptr = ptr->next; } } void strrev(char *str) { int i,j; for (i=0,j=strlen(str)-1;i<j;i++,j--) { str[i]^=str[j]^=str[i]^=str[j]; } } int isoper(char ch) { switch(ch) { case '%': case '/': case '*': case '+': case '-': case '$': case '^': return 1; default: return 0; } } int prio(char ch) { if ( (ch == '^') || (ch == '$')) return 3; else if ((ch == '/') || (ch == '%') || (ch == '*')) return 2; else if ((ch == '+') || (ch == '-')) return 1; else return 0; } void infix2prefix(struct stack **top, char *str,char *result) { int i=0; char x; while (*str != '0') { if ((*str == \"\") || (*str == 't')) continue; if( isoper(*str) ) { while ((prio(*str) < prio(gettop(top)))) { result[i++] = pop(top); } push(top,*str); } else if ( *str == ')') { push(top,*str); } else if ( *str == '(') { while( (x = pop(top)) != ')' ) { result[i++] = x; } //pop(top); } else { result[i++] = *str; } str++; } while( (x = pop(top)) != NULL ) { result[i++] = x; } result[i] = '0'; } void main() { struct stack *top = NULL; char expr[] = \"4$2*3-3+8/4/(1+1)\"; char *result; result = malloc(sizeof(expr)); printf(\"infix expression = %sn\",expr); strrev(expr); printf(\"reverse expression = %sn\",expr); infix2prefix(&top,expr,result); strrev(result); printf(\"prefix expression = %sn\",result); }","title":"Infix to prefix conversion using stack with linklist"},{"location":"data-structure/infix-to-prefix-conversion-using-stack-with-linklist/#infix-to-prefix-conversion-using-stack-with-linklist","text":"OCTOBER 16, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #include <string.h> struct stack { char data; struct stack *next; }; void push(struct stack **top, char num) { struct stack *temp; temp=malloc(sizeof(struct stack)); if (temp == NULL) { printf(\"Stack is fulln\"); return; } temp->data = num; temp->next = NULL; if ((*top) == NULL) { (*top)=temp; } else { temp->next = (*top); (*top) = temp; } } char pop(struct stack **top) { struct stack *temp; char data; if ((*top) == NULL) { //printf(\"Stack is emptyn\"); return NULL; } temp = (*top); (*top)=(*top)->next; data = temp->data; free(temp); return(data); } char gettop(struct stack **top) { if ((*top) == NULL) { //printf(\"Stack is emptyn\"); return NULL; } return((*top)->data); } void display(struct stack *top) { struct stack *ptr = top; //ptr=top; printf(\"| TOP |n\"); while ( ptr != NULL ) { printf (\"| %c |n\",ptr->data); ptr = ptr->next; } } void strrev(char *str) { int i,j; for (i=0,j=strlen(str)-1;i<j;i++,j--) { str[i]^=str[j]^=str[i]^=str[j]; } } int isoper(char ch) { switch(ch) { case '%': case '/': case '*': case '+': case '-': case '$': case '^': return 1; default: return 0; } } int prio(char ch) { if ( (ch == '^') || (ch == '$')) return 3; else if ((ch == '/') || (ch == '%') || (ch == '*')) return 2; else if ((ch == '+') || (ch == '-')) return 1; else return 0; } void infix2prefix(struct stack **top, char *str,char *result) { int i=0; char x; while (*str != '0') { if ((*str == \"\") || (*str == 't')) continue; if( isoper(*str) ) { while ((prio(*str) < prio(gettop(top)))) { result[i++] = pop(top); } push(top,*str); } else if ( *str == ')') { push(top,*str); } else if ( *str == '(') { while( (x = pop(top)) != ')' ) { result[i++] = x; } //pop(top); } else { result[i++] = *str; } str++; } while( (x = pop(top)) != NULL ) { result[i++] = x; } result[i] = '0'; } void main() { struct stack *top = NULL; char expr[] = \"4$2*3-3+8/4/(1+1)\"; char *result; result = malloc(sizeof(expr)); printf(\"infix expression = %sn\",expr); strrev(expr); printf(\"reverse expression = %sn\",expr); infix2prefix(&top,expr,result); strrev(result); printf(\"prefix expression = %sn\",result); }","title":"Infix to Prefix conversion using Stack with Linklist"},{"location":"data-structure/ipc-pipes/","text":"Program to implement IPC Pipes SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: pipes.c */ #include <stdio.h> #include <unistd.h> #include <errno.h> #define MAX_SIZE 30 /* * main() */ int main(int argc,char *argv[]) { int pipefd[2]; char recive_buffer[MAX_SIZE]; char send_buffer[MAX_SIZE]; /* create pipe */ if (pipe(pipefd) < 0 ) { perror(\"Fail to open pipen\"); return -2; } printf(\"Enter String: \"); scanf(\"%[^n]s\", send_buffer); /* sending data on pipefd */ printf(\"Sending data to pipe : %sn\", send_buffer); write(pipefd[1], send_buffer, sizeof(send_buffer)); /* receiving data on pipefd */ read(pipefd[0], &recive_buffer, sizeof(send_buffer)); printf(\"Received data from pipe : %sn\", recive_buffer); close(pipefd[0]); /* close read end */ close(pipefd[1]); /* close write end */ return 0; } Compilation Steps: $ gcc -o pipes pipes.c Output: Enter String: hello world Sending data to pipe : hello world Received data from pipe : hello world","title":"Ipc pipes"},{"location":"data-structure/ipc-pipes/#program-to-implement-ipc-pipes","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: pipes.c */ #include <stdio.h> #include <unistd.h> #include <errno.h> #define MAX_SIZE 30 /* * main() */ int main(int argc,char *argv[]) { int pipefd[2]; char recive_buffer[MAX_SIZE]; char send_buffer[MAX_SIZE]; /* create pipe */ if (pipe(pipefd) < 0 ) { perror(\"Fail to open pipen\"); return -2; } printf(\"Enter String: \"); scanf(\"%[^n]s\", send_buffer); /* sending data on pipefd */ printf(\"Sending data to pipe : %sn\", send_buffer); write(pipefd[1], send_buffer, sizeof(send_buffer)); /* receiving data on pipefd */ read(pipefd[0], &recive_buffer, sizeof(send_buffer)); printf(\"Received data from pipe : %sn\", recive_buffer); close(pipefd[0]); /* close read end */ close(pipefd[1]); /* close write end */ return 0; }","title":"Program to implement IPC Pipes"},{"location":"data-structure/ipc-pipes/#compilation-steps","text":"$ gcc -o pipes pipes.c","title":"Compilation Steps:"},{"location":"data-structure/ipc-pipes/#output","text":"Enter String: hello world Sending data to pipe : hello world Received data from pipe : hello world","title":"Output:"},{"location":"data-structure/linked-list/","text":"Program to implement a linked list SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> struct node { int data; struct node *next; }; /* Count all element of List */ void CountElements(struct node *ptr) { int count = 0; while (ptr != NULL) { count++; ptr = ptr->next; } printf(\"List Count = %dn\", count); } /* Print all element of List */ void printList(struct node *ptr) { printf(\"Start --> \"); while (ptr != NULL) { printf(\"%d --> \", ptr->data); ptr = ptr->next; } printf(\" NULL n\"); } /* Add element by Index */ int addElement(struct node **ptr, int num) { struct node *p, *t = *ptr; /* Allocate node */ p = (struct node *)malloc(sizeof(struct node)); p->data = num; p->next = NULL; if (t == NULL) { *ptr = p; } else { while (t->next != NULL) t = t->next; t->next = p; } return 0; } /* Add element by Index */ int addElementAtIndex(struct node **ptr, int index, int num) { struct node *q = NULL, *p = *ptr; int count = 1; /* Allocate node */ q = (struct node *)malloc(sizeof(struct node)); q->data = num; q->next = NULL; while ((p != NULL) && (++count < index)) { p = p->next; } if (count != index) return -1; q->next = p->next; p->next = q; return 0; } /* Delete element by content */ int delElementByValue(struct node **ptr, int num) { struct node *p = *ptr; struct node *q = NULL; if (p->data == num) { q = p; (*ptr) = q->next; free(q); } else { q = (*ptr)->next; while ((q != NULL) && (q->data != num)) { p = p->next; q = q->next; } if (q != NULL) { p->next = q->next; free(q); } } return 0; } /* Delete element by Index */ int delElementByIndex(struct node **ptr, int index) { struct node *p = *ptr; struct node *q = NULL; int count = 1; while ((p != NULL) && (++count < index)) { p = p->next; } if (count != index) return -1; if (p != NULL) { q = p->next; p->next = q->next; free(q); } return 0; } /* Reverse Link List */ int reverseList(struct node **ptr) { struct node *q = *ptr, *p = *ptr; struct node *r = NULL; if ((p == NULL) || (p->next == NULL)) { return 0; } while (q != NULL) { q = p->next; p->next = r; r = p; p = q; } (*ptr) = r; return 0; } int main() { struct node *list = NULL; addElement(&list, 43); addElement(&list, 54); printList(list); reverseList(&list); printList(list); addElement(&list, 35); addElement(&list, 67); addElement(&list, 94); addElement(&list, 86); printList(list); CountElements(list); delElementByValue(&list, 67); delElementByValue(&list, 43); printList(list); delElementByIndex(&list, 3); printList(list); addElementAtIndex(&list, 3, 44); printList(list); reverseList(&list); printList(list); return 0; }","title":"Linked list"},{"location":"data-structure/linked-list/#program-to-implement-a-linked-list","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> struct node { int data; struct node *next; }; /* Count all element of List */ void CountElements(struct node *ptr) { int count = 0; while (ptr != NULL) { count++; ptr = ptr->next; } printf(\"List Count = %dn\", count); } /* Print all element of List */ void printList(struct node *ptr) { printf(\"Start --> \"); while (ptr != NULL) { printf(\"%d --> \", ptr->data); ptr = ptr->next; } printf(\" NULL n\"); } /* Add element by Index */ int addElement(struct node **ptr, int num) { struct node *p, *t = *ptr; /* Allocate node */ p = (struct node *)malloc(sizeof(struct node)); p->data = num; p->next = NULL; if (t == NULL) { *ptr = p; } else { while (t->next != NULL) t = t->next; t->next = p; } return 0; } /* Add element by Index */ int addElementAtIndex(struct node **ptr, int index, int num) { struct node *q = NULL, *p = *ptr; int count = 1; /* Allocate node */ q = (struct node *)malloc(sizeof(struct node)); q->data = num; q->next = NULL; while ((p != NULL) && (++count < index)) { p = p->next; } if (count != index) return -1; q->next = p->next; p->next = q; return 0; } /* Delete element by content */ int delElementByValue(struct node **ptr, int num) { struct node *p = *ptr; struct node *q = NULL; if (p->data == num) { q = p; (*ptr) = q->next; free(q); } else { q = (*ptr)->next; while ((q != NULL) && (q->data != num)) { p = p->next; q = q->next; } if (q != NULL) { p->next = q->next; free(q); } } return 0; } /* Delete element by Index */ int delElementByIndex(struct node **ptr, int index) { struct node *p = *ptr; struct node *q = NULL; int count = 1; while ((p != NULL) && (++count < index)) { p = p->next; } if (count != index) return -1; if (p != NULL) { q = p->next; p->next = q->next; free(q); } return 0; } /* Reverse Link List */ int reverseList(struct node **ptr) { struct node *q = *ptr, *p = *ptr; struct node *r = NULL; if ((p == NULL) || (p->next == NULL)) { return 0; } while (q != NULL) { q = p->next; p->next = r; r = p; p = q; } (*ptr) = r; return 0; } int main() { struct node *list = NULL; addElement(&list, 43); addElement(&list, 54); printList(list); reverseList(&list); printList(list); addElement(&list, 35); addElement(&list, 67); addElement(&list, 94); addElement(&list, 86); printList(list); CountElements(list); delElementByValue(&list, 67); delElementByValue(&list, 43); printList(list); delElementByIndex(&list, 3); printList(list); addElementAtIndex(&list, 3, 44); printList(list); reverseList(&list); printList(list); return 0; }","title":"Program to implement a linked list"},{"location":"data-structure/machine-endianess/","text":"Program to find machine endianness SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Program to find machine endianness */ #include <stdio.h> int main() { int x=0x1; char* c= (char *)&x; if (*c == 1) printf (\"Little endiann\"); else printf (\"Big endiann\"); return 0; }","title":"Machine endianess"},{"location":"data-structure/machine-endianess/#program-to-find-machine-endianness","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Program to find machine endianness */ #include <stdio.h> int main() { int x=0x1; char* c= (char *)&x; if (*c == 1) printf (\"Little endiann\"); else printf (\"Big endiann\"); return 0; }","title":"Program to find machine endianness"},{"location":"data-structure/message-queue/","text":"Program to implement Message Queue SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM mq_reader: /* * file: mq_reader.c */ #include <stdio.h> #include <fcntl.h> #include <sys/stat.h> #include <mqueue.h> #include <errno.h> #include <unistd.h> #include <string.h> #define MSG_Q_NAME \"/MSG_Q\" #define NO_MAX_MSG 10 #define MAX_MSG 1024 #define STOP_CMD \"exit\" /* main () */ int main(int agrc, char *argv[]) { mqd_t msg_q; struct mq_attr attr; char message[MAX_MSG]; int mq_len; attr.mq_flags = 0; attr.mq_maxmsg = NO_MAX_MSG; attr.mq_msgsize = MAX_MSG; attr.mq_curmsgs = 0; msg_q = mq_open (MSG_Q_NAME,O_CREAT|O_RDONLY,S_IRUSR | S_IWUSR| S_IRGRP| S_IROTH, &attr); if ( -1 == msg_q) { perror(\"mq_open\"); _exit(-1); } do { bzero(message, MAX_MSG); mq_len = mq_receive(msg_q, message, MAX_MSG, NULL); if ( -1 == mq_len) { perror(\"mq_receive\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); _exit(-1); } printf(\"nReceived $ %sn\", message); } while (!(0 == strcmp(message,STOP_CMD))); printf(\"nmq_reader: Exitn\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); return 0; } Program mq_writer: /* * file: mq_writer.c */ #include <stdio.h> #include <fcntl.h> #include <sys/stat.h> #include <mqueue.h> #include <errno.h> #include <unistd.h> #include <string.h> #define MSG_Q_NAME \"/MSG_Q\" #define NO_MAX_MSG 10 #define MAX_MSG 1024 #define STOP_CMD \"exit\" /* main () */ int main(int agrc, char *argv[]) { mqd_t msg_q; struct mq_attr attr; int mq_len; char message[MAX_MSG]; attr.mq_flags = 0; attr.mq_maxmsg = NO_MAX_MSG; attr.mq_msgsize = MAX_MSG; attr.mq_curmsgs = 0; msg_q = mq_open (MSG_Q_NAME,O_WRONLY,S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, &attr); if ( -1 == msg_q) { perror(\"mq_open\"); _exit(-1); } printf(\"nEnter \"exit\" to stop: \"); do { bzero(message, MAX_MSG); printf(\"nSend $ \"); gets(message); mq_len = strlen(message); if ( -1 == mq_send(msg_q, message, mq_len, 0)) { perror(\"mq_send\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); _exit(-1); } } while (!(0 == strcmp(message, STOP_CMD))); printf(\"mq_writer: Exitn\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); return 0; } Compilation Steps: $ gcc -o mq_writer mq_writer.c -lrt $ gcc -o mq_reader mq_reader.c -lrt Output: $ ./mq_reader& $ ./mq_writer Enter \"exit\" to stop: Send $ hello are u Received $ hello are u Send $ exit Received $ exit mq_writer: Exit mq_reader: Exit [1]+ Done ./mq_reader","title":"Message queue"},{"location":"data-structure/message-queue/#program-to-implement-message-queue","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM","title":"Program to implement Message Queue"},{"location":"data-structure/message-queue/#mq_reader","text":"/* * file: mq_reader.c */ #include <stdio.h> #include <fcntl.h> #include <sys/stat.h> #include <mqueue.h> #include <errno.h> #include <unistd.h> #include <string.h> #define MSG_Q_NAME \"/MSG_Q\" #define NO_MAX_MSG 10 #define MAX_MSG 1024 #define STOP_CMD \"exit\" /* main () */ int main(int agrc, char *argv[]) { mqd_t msg_q; struct mq_attr attr; char message[MAX_MSG]; int mq_len; attr.mq_flags = 0; attr.mq_maxmsg = NO_MAX_MSG; attr.mq_msgsize = MAX_MSG; attr.mq_curmsgs = 0; msg_q = mq_open (MSG_Q_NAME,O_CREAT|O_RDONLY,S_IRUSR | S_IWUSR| S_IRGRP| S_IROTH, &attr); if ( -1 == msg_q) { perror(\"mq_open\"); _exit(-1); } do { bzero(message, MAX_MSG); mq_len = mq_receive(msg_q, message, MAX_MSG, NULL); if ( -1 == mq_len) { perror(\"mq_receive\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); _exit(-1); } printf(\"nReceived $ %sn\", message); } while (!(0 == strcmp(message,STOP_CMD))); printf(\"nmq_reader: Exitn\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); return 0; }","title":"mq_reader:"},{"location":"data-structure/message-queue/#program-mq_writer","text":"/* * file: mq_writer.c */ #include <stdio.h> #include <fcntl.h> #include <sys/stat.h> #include <mqueue.h> #include <errno.h> #include <unistd.h> #include <string.h> #define MSG_Q_NAME \"/MSG_Q\" #define NO_MAX_MSG 10 #define MAX_MSG 1024 #define STOP_CMD \"exit\" /* main () */ int main(int agrc, char *argv[]) { mqd_t msg_q; struct mq_attr attr; int mq_len; char message[MAX_MSG]; attr.mq_flags = 0; attr.mq_maxmsg = NO_MAX_MSG; attr.mq_msgsize = MAX_MSG; attr.mq_curmsgs = 0; msg_q = mq_open (MSG_Q_NAME,O_WRONLY,S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH, &attr); if ( -1 == msg_q) { perror(\"mq_open\"); _exit(-1); } printf(\"nEnter \"exit\" to stop: \"); do { bzero(message, MAX_MSG); printf(\"nSend $ \"); gets(message); mq_len = strlen(message); if ( -1 == mq_send(msg_q, message, mq_len, 0)) { perror(\"mq_send\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); _exit(-1); } } while (!(0 == strcmp(message, STOP_CMD))); printf(\"mq_writer: Exitn\"); mq_close(msg_q); mq_unlink(MSG_Q_NAME); return 0; }","title":"Program mq_writer:"},{"location":"data-structure/message-queue/#compilation-steps","text":"$ gcc -o mq_writer mq_writer.c -lrt $ gcc -o mq_reader mq_reader.c -lrt","title":"Compilation Steps:"},{"location":"data-structure/message-queue/#output","text":"$ ./mq_reader& $ ./mq_writer Enter \"exit\" to stop: Send $ hello are u Received $ hello are u Send $ exit Received $ exit mq_writer: Exit mq_reader: Exit [1]+ Done ./mq_reader","title":"Output:"},{"location":"data-structure/named-pipe/","text":"Program to Read & Write Named Pipe SEPTEMBER 29,2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: named_pipe.c */ #include <stdio.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <errno.h> #define MAX_SIZE 1024 #define FIFO_NAME \"MYFIFO\" /* main()*/ int main(int argc, char *argv[]) { char *fifo_f = FIFO_NAME; int fifo_fd; char send_msg[MAX_SIZE]; char rec_msg[MAX_SIZE]; /* create fifo */ if (-1 == mkfifo(fifo_f, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) { perror(\"reader:mkfifo\"); _exit(-2);; } /* open fifo */ fifo_fd = open(fifo_f, O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); if (-1 == fifo_fd) { perror(\"file open\"); _exit(-3);; } printf(\"nSend $ \"); gets(send_msg); //scanf(\"%[^n]s\", send_msg); /* write fifo */ if (-1 == write(fifo_fd, send_msg, sizeof(send_msg))) { perror(\"write fails\"); _exit(-4);; } /* write fifo */ if (-1 == read(fifo_fd, &rec_msg, sizeof(send_msg))) { perror(\"read fails\"); _exit(-4);; } printf(\"nReceived $ %sn\", rec_msg); /* close fifo fd */ close(fifo_fd); /* close fifo */ unlink(fifo_f); return 0; }","title":"Named pipe"},{"location":"data-structure/named-pipe/#program-to-read-write-named-pipe","text":"SEPTEMBER 29,2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: named_pipe.c */ #include <stdio.h> #include <sys/types.h> #include <sys/stat.h> #include <fcntl.h> #include <unistd.h> #include <errno.h> #define MAX_SIZE 1024 #define FIFO_NAME \"MYFIFO\" /* main()*/ int main(int argc, char *argv[]) { char *fifo_f = FIFO_NAME; int fifo_fd; char send_msg[MAX_SIZE]; char rec_msg[MAX_SIZE]; /* create fifo */ if (-1 == mkfifo(fifo_f, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH)) { perror(\"reader:mkfifo\"); _exit(-2);; } /* open fifo */ fifo_fd = open(fifo_f, O_CREAT | O_TRUNC | O_RDWR, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH); if (-1 == fifo_fd) { perror(\"file open\"); _exit(-3);; } printf(\"nSend $ \"); gets(send_msg); //scanf(\"%[^n]s\", send_msg); /* write fifo */ if (-1 == write(fifo_fd, send_msg, sizeof(send_msg))) { perror(\"write fails\"); _exit(-4);; } /* write fifo */ if (-1 == read(fifo_fd, &rec_msg, sizeof(send_msg))) { perror(\"read fails\"); _exit(-4);; } printf(\"nReceived $ %sn\", rec_msg); /* close fifo fd */ close(fifo_fd); /* close fifo */ unlink(fifo_f); return 0; }","title":"Program to Read &amp; Write Named Pipe"},{"location":"data-structure/queue-implementation-using-array/","text":"Queue implementation using array OCTOBER 16, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #define MAX (4) struct queue { int data[MAX]; short int front; short int rear; }; void init_queue (struct queue *q) { q->front =q->rear = -1; /* empty */ } void addq(struct queue *q, int num) { if (q->rear == MAX - 1) { printf(\"Cannot insert %d, Queue is fulln\", num); return; } q->rear++; q->data[q->rear] = num; if (q->front == -1 ) { q->front = q->rear; } } int delq(struct queue *q) { int data; if (q->front == -1 ) { printf(\"Queue is emptyn\"); return -1; } data=q->data[q->front]; if (q->front == MAX-1 ) { q->rear=q->front = -1; } else { q->front++; } return data; } void showq(struct queue *q) { int counter=0; printf(\"nFRONT(%d) --> \", q->front); for (counter = q->front; q->front != -1 && counter <= q->rear; counter++) { printf(\"%d --> \", q->data[counter]); } printf(\" --> REAR(%d)n\",q->rear); } int main() { struct queue que; int x,i; printf(\"Hello Queuen\"); init_queue(&que); addq(&que, 12); addq(&que, 45); addq(&que, 34); addq(&que, 77); addq(&que, 83); showq(&que); for (i=0;i<1;i++) { x=delq(&que); printf(\"Item delete = %dn\", x); } showq(&que); addq(&que, 83); showq(&que); return 0; }","title":"Queue implementation using array"},{"location":"data-structure/queue-implementation-using-array/#queue-implementation-using-array","text":"OCTOBER 16, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #define MAX (4) struct queue { int data[MAX]; short int front; short int rear; }; void init_queue (struct queue *q) { q->front =q->rear = -1; /* empty */ } void addq(struct queue *q, int num) { if (q->rear == MAX - 1) { printf(\"Cannot insert %d, Queue is fulln\", num); return; } q->rear++; q->data[q->rear] = num; if (q->front == -1 ) { q->front = q->rear; } } int delq(struct queue *q) { int data; if (q->front == -1 ) { printf(\"Queue is emptyn\"); return -1; } data=q->data[q->front]; if (q->front == MAX-1 ) { q->rear=q->front = -1; } else { q->front++; } return data; } void showq(struct queue *q) { int counter=0; printf(\"nFRONT(%d) --> \", q->front); for (counter = q->front; q->front != -1 && counter <= q->rear; counter++) { printf(\"%d --> \", q->data[counter]); } printf(\" --> REAR(%d)n\",q->rear); } int main() { struct queue que; int x,i; printf(\"Hello Queuen\"); init_queue(&que); addq(&que, 12); addq(&que, 45); addq(&que, 34); addq(&que, 77); addq(&que, 83); showq(&que); for (i=0;i<1;i++) { x=delq(&que); printf(\"Item delete = %dn\", x); } showq(&que); addq(&que, 83); showq(&que); return 0; }","title":"Queue implementation using array"},{"location":"data-structure/remove-white-space-from-a-string/","text":"Program to remove leading space from a string SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #include <string.h> /* * function to remove leading and trailing * space from 'src' and store it in 'dst'. */ void xtrim(char *dst,const char *src) { /* Remove leading white space */ while ( (*src == ' ') || (*src == 't') ) { *src++; } while ( (*dst++ = *src++) != '0'); /* Remove trailing white space */ dst--; dst--; while ( (*dst == ' ') || (*dst == 't') ) { *dst--; } *++dst ='\\0'; } void main() { char str[]=\" India is Great \"; char *result; result = (char *) malloc(strlen(str)); printf(\"length of string before trim = %dn\", strlen(str)); xtrim(result,str); printf(\"String = \"%s\"n\",result); printf(\"length of string after trim = %dn\", strlen(result)); free(result); }","title":"Remove white space from a string"},{"location":"data-structure/remove-white-space-from-a-string/#program-to-remove-leading-space-from-a-string","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #include <string.h> /* * function to remove leading and trailing * space from 'src' and store it in 'dst'. */ void xtrim(char *dst,const char *src) { /* Remove leading white space */ while ( (*src == ' ') || (*src == 't') ) { *src++; } while ( (*dst++ = *src++) != '0'); /* Remove trailing white space */ dst--; dst--; while ( (*dst == ' ') || (*dst == 't') ) { *dst--; } *++dst ='\\0'; } void main() { char str[]=\" India is Great \"; char *result; result = (char *) malloc(strlen(str)); printf(\"length of string before trim = %dn\", strlen(str)); xtrim(result,str); printf(\"String = \"%s\"n\",result); printf(\"length of string after trim = %dn\", strlen(result)); free(result); }","title":"Program to remove leading space from a string"},{"location":"data-structure/reverse-bits/","text":"Program to reverse bits in number SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Program to Reverse bits in a number */ #include <stdio.h> /* * Change NBITS as per your requirment * NBIT = 1, reverse each bit * NBIT = 4, reverse the nibble * NBIT = 8, reverse the bytes */ #define NBITS 0x4 #define NBIT_MASK (~(~0 << NBITS)) int reverse_bits(int m){ int n=0; while ( m != 0 ) { n <<=NBITS; n |= (m & NBIT_MASK); m >>= NBITS; } return n; } int main() { int num=0x1234; printf (\"Initial Number=0x%xn\", num); printf (\"Reverse %d bits in Number=0x%xn\",NBITS, reverse_bits(num)); return 0; }","title":"Reverse bits"},{"location":"data-structure/reverse-bits/#program-to-reverse-bits-in-number","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Program to Reverse bits in a number */ #include <stdio.h> /* * Change NBITS as per your requirment * NBIT = 1, reverse each bit * NBIT = 4, reverse the nibble * NBIT = 8, reverse the bytes */ #define NBITS 0x4 #define NBIT_MASK (~(~0 << NBITS)) int reverse_bits(int m){ int n=0; while ( m != 0 ) { n <<=NBITS; n |= (m & NBIT_MASK); m >>= NBITS; } return n; } int main() { int num=0x1234; printf (\"Initial Number=0x%xn\", num); printf (\"Reverse %d bits in Number=0x%xn\",NBITS, reverse_bits(num)); return 0; }","title":"Program to reverse bits in number"},{"location":"data-structure/reverse-number/","text":"Program to reverse a decimal number SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Program to Reverse a number */ #include <stdio.h> int reverse_number(int n){ int out = 0; while(n!=0){ out *= 10; out += n%10; n /= 10; } return out; } int main() { int num=1234; printf (\"Initial Number=%dn\", num); printf (\"Reverse Number=%dn\",reverse_number(num)); return 0; }","title":"Reverse number"},{"location":"data-structure/reverse-number/#program-to-reverse-a-decimal-number","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Program to Reverse a number */ #include <stdio.h> int reverse_number(int n){ int out = 0; while(n!=0){ out *= 10; out += n%10; n /= 10; } return out; } int main() { int num=1234; printf (\"Initial Number=%dn\", num); printf (\"Reverse Number=%dn\",reverse_number(num)); return 0; }","title":"Program to reverse a decimal number"},{"location":"data-structure/set-multiple-bits/","text":"Program to set multiple bits SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Write a program to set multiple bits */ #include <stdio.h> /* * Set bits from m to n bits (both inclusive) for value x * where x is positive integer number * and 31 >= n > m >=0 */ #define BITMASK_METHOD1(m,n) (((1<<(n-m+1))-1)<<m) #define BITMASK_METHOD2(m,n) ((~(~0 << ((n) -(m)+1))) << (m)) #define SETBITS(x,m,n) ((x) | (((1<<((n)-(m)+1))-1)<<(m))) int main() { int num1=0, num2=0; num1=0x1b; num2=SETBITS(num1,3,7); printf(\"num1=0x%x num2=0x%xn\",num1 ,num2); return 0; }","title":"Set multiple bits"},{"location":"data-structure/set-multiple-bits/#program-to-set-multiple-bits","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* Write a program to set multiple bits */ #include <stdio.h> /* * Set bits from m to n bits (both inclusive) for value x * where x is positive integer number * and 31 >= n > m >=0 */ #define BITMASK_METHOD1(m,n) (((1<<(n-m+1))-1)<<m) #define BITMASK_METHOD2(m,n) ((~(~0 << ((n) -(m)+1))) << (m)) #define SETBITS(x,m,n) ((x) | (((1<<((n)-(m)+1))-1)<<(m))) int main() { int num1=0, num2=0; num1=0x1b; num2=SETBITS(num1,3,7); printf(\"num1=0x%x num2=0x%xn\",num1 ,num2); return 0; }","title":"Program to set multiple bits"},{"location":"data-structure/stack-implementation-using-linkedlist/","text":"Implementation of Stack using Linklist OCTOBER 16, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> struct stack { int data; struct stack *next; }; void push(struct stack **top, int num) { struct stack *temp; temp=malloc(sizeof(struct stack)); if (temp == NULL) { printf(\"Stack is fulln\"); return; } temp->data = num; temp->next = NULL; if ((*top) == NULL) { (*top)=temp; } else { temp->next = (*top); (*top) = temp; } } int pop(struct stack **top) { struct stack *temp; int data; if ((*top) == NULL) { printf(\"Stack is emptyn\"); return NULL; } temp = (*top); (*top)=(*top)->next; data = temp->data; free(temp); return(data); } void display(struct stack *top) { struct stack *ptr; ptr=top; printf(\"| TOP |n\"); while (ptr != NULL ) { printf (\"| %d |n\",ptr->data); ptr = ptr->next; } } void main() { struct stack *top; push(&top,12); display(top); }","title":"Stack implementation using linkedlist"},{"location":"data-structure/stack-implementation-using-linkedlist/#implementation-of-stack-using-linklist","text":"OCTOBER 16, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> struct stack { int data; struct stack *next; }; void push(struct stack **top, int num) { struct stack *temp; temp=malloc(sizeof(struct stack)); if (temp == NULL) { printf(\"Stack is fulln\"); return; } temp->data = num; temp->next = NULL; if ((*top) == NULL) { (*top)=temp; } else { temp->next = (*top); (*top) = temp; } } int pop(struct stack **top) { struct stack *temp; int data; if ((*top) == NULL) { printf(\"Stack is emptyn\"); return NULL; } temp = (*top); (*top)=(*top)->next; data = temp->data; free(temp); return(data); } void display(struct stack *top) { struct stack *ptr; ptr=top; printf(\"| TOP |n\"); while (ptr != NULL ) { printf (\"| %d |n\",ptr->data); ptr = ptr->next; } } void main() { struct stack *top; push(&top,12); display(top); }","title":"Implementation of Stack using Linklist"},{"location":"data-structure/stack-operations/","text":"Programs for Stack operations OCTOBER 14, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <string.h> #include <stdlib.h> #include <ctype.h> #define MAX 30 struct stack { char *data ; int top; int limit; }; int init_stack(struct stack **s, int size) { struct stack *p=(*s); p=malloc(sizeof(struct stack)); if (p == NULL) return -1; p->top =-1; p->limit = size; p->data = (char *)malloc(sizeof(p->limit)); if (p->data == NULL) { free(p); return -2; } else { strcpy(p->data,\"\"); } (*s)=p; return 0; } void destroy_stack(struct stack **s) { if ((*s) && (*s)->data != NULL) free((*s)->data); if(*s) free(*s); } void push(struct stack **s, char ch) { struct stack *p=*s; if (p->top >= MAX) { printf(\"nStack is fulln\"); } else { ++p->top; p->data[p->top] = ch; } } char pop(struct stack **s) { struct stack *p=(*s); char ch; if ( p->top == -1) { printf(\"nStack is emptyn\"); } else { ch = p->data[p->top]; --p->top; //printf(\"n%s: top=%d\",__func__,p->top); } return ch; } char gettop(struct stack *s) { return s->data[s->top]; } void print_stack(struct stack *p) { int i=-1; if(p) { printf(\"nStack elements are (top=%d): \", p->top); for (i=0;i<=p->top;i++) { printf(\"%c\",p->data[i]); } } } int main() { struct stack *stk; init_stack(&stk,MAX); push(&stk,'c'); push(&stk,'d'); pop(&stk); print_stack(stk); printf(\"nStack top element is %c\",gettop(stk)); destroy_stack(&stk); return 0; }","title":"Stack operations"},{"location":"data-structure/stack-operations/#programs-for-stack-operations","text":"OCTOBER 14, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <string.h> #include <stdlib.h> #include <ctype.h> #define MAX 30 struct stack { char *data ; int top; int limit; }; int init_stack(struct stack **s, int size) { struct stack *p=(*s); p=malloc(sizeof(struct stack)); if (p == NULL) return -1; p->top =-1; p->limit = size; p->data = (char *)malloc(sizeof(p->limit)); if (p->data == NULL) { free(p); return -2; } else { strcpy(p->data,\"\"); } (*s)=p; return 0; } void destroy_stack(struct stack **s) { if ((*s) && (*s)->data != NULL) free((*s)->data); if(*s) free(*s); } void push(struct stack **s, char ch) { struct stack *p=*s; if (p->top >= MAX) { printf(\"nStack is fulln\"); } else { ++p->top; p->data[p->top] = ch; } } char pop(struct stack **s) { struct stack *p=(*s); char ch; if ( p->top == -1) { printf(\"nStack is emptyn\"); } else { ch = p->data[p->top]; --p->top; //printf(\"n%s: top=%d\",__func__,p->top); } return ch; } char gettop(struct stack *s) { return s->data[s->top]; } void print_stack(struct stack *p) { int i=-1; if(p) { printf(\"nStack elements are (top=%d): \", p->top); for (i=0;i<=p->top;i++) { printf(\"%c\",p->data[i]); } } } int main() { struct stack *stk; init_stack(&stk,MAX); push(&stk,'c'); push(&stk,'d'); pop(&stk); print_stack(stk); printf(\"nStack top element is %c\",gettop(stk)); destroy_stack(&stk); return 0; }","title":"Programs for Stack operations"},{"location":"data-structure/string-copy/","text":"Write a program to copy a string ? SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #include <string.h> /* * function to copy string * dst = output string * src = source string */ void xstrcpy(char *dst,const char *src) { while ( (*dst++ = *src++) != '0'); } void main() { char str[]=\"India is Great\"; char *result; result = (char *) malloc(strlen(str)); xstrcpy(result,str); printf(\"%sn\",result); free(result); }","title":"String copy"},{"location":"data-structure/string-copy/#write-a-program-to-copy-a-string","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM #include <stdio.h> #include <stdlib.h> #include <string.h> /* * function to copy string * dst = output string * src = source string */ void xstrcpy(char *dst,const char *src) { while ( (*dst++ = *src++) != '0'); } void main() { char str[]=\"India is Great\"; char *result; result = (char *) malloc(strlen(str)); xstrcpy(result,str); printf(\"%sn\",result); free(result); }","title":"Write a program to copy a string ?"},{"location":"data-structure/string-length/","text":"Program to find length of given string SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: mystrlen.c */ /* Program to calculate string length */ #include <stdio.h> int xstrlen(char *); int ystrlen(char *); int zstrlen(char *); int main(int argc, char *argv[]) { int res=0; char *str=argv[1]; if (argc < 2 ) { printf(\"Invalid argumentn\"); printf(\"Usage: %s <string> n\", argv[0]); return -1; } /* Method 1 */ printf(\"Input : %sn\", str); res = xstrlen(str); printf(\"Length of String \"%s\" is : %dn\", str, res); /* Method 2 */ res=0; res =ystrlen(str); printf(\"Length of String \"%s\" is : %dn\", str, res); /* Method 3 */ res=0; res =zstrlen(str); printf(\"Length of String \"%s\" is : %dn\", str, res); return 0; } /* Method 1: Using while loop */ int xstrlen(char *str) { int count=0; while (*str++ != '0' ) count++; return count; } /* Method 2: Using for loop */ int ystrlen(char *str) { int count=0; for(count=0; *str != 0; str++, count++); return count; } /* Method 3: Using pointer */ int zstrlen(char *str) { char *ptr=str; while (*ptr++ != '0' ); return (ptr - str -1); } Compilation Steps: $ gcc -o mystrlen mystrlen.c Output: $ ./strlen \"Hello World\" Input : Hello World Length of String \"Hello World\" is : 11 Length of String \"Hello World\" is : 11 Length of String \"Hello World\" is : 11","title":"String length"},{"location":"data-structure/string-length/#program-to-find-length-of-given-string","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* * file: mystrlen.c */ /* Program to calculate string length */ #include <stdio.h> int xstrlen(char *); int ystrlen(char *); int zstrlen(char *); int main(int argc, char *argv[]) { int res=0; char *str=argv[1]; if (argc < 2 ) { printf(\"Invalid argumentn\"); printf(\"Usage: %s <string> n\", argv[0]); return -1; } /* Method 1 */ printf(\"Input : %sn\", str); res = xstrlen(str); printf(\"Length of String \"%s\" is : %dn\", str, res); /* Method 2 */ res=0; res =ystrlen(str); printf(\"Length of String \"%s\" is : %dn\", str, res); /* Method 3 */ res=0; res =zstrlen(str); printf(\"Length of String \"%s\" is : %dn\", str, res); return 0; } /* Method 1: Using while loop */ int xstrlen(char *str) { int count=0; while (*str++ != '0' ) count++; return count; } /* Method 2: Using for loop */ int ystrlen(char *str) { int count=0; for(count=0; *str != 0; str++, count++); return count; } /* Method 3: Using pointer */ int zstrlen(char *str) { char *ptr=str; while (*ptr++ != '0' ); return (ptr - str -1); }","title":"Program to find length of given string"},{"location":"data-structure/string-length/#compilation-steps","text":"$ gcc -o mystrlen mystrlen.c","title":"Compilation Steps:"},{"location":"data-structure/string-length/#output","text":"$ ./strlen \"Hello World\" Input : Hello World Length of String \"Hello World\" is : 11 Length of String \"Hello World\" is : 11 Length of String \"Hello World\" is : 11","title":"Output:"},{"location":"data-structure/string-reverse/","text":"Program to reverse input string SEPTEMBER 29,2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* file: strrev.c */ /* Program to reverse string */ #include <stdio.h> /* Declarations */ void swap(char *s, char *d) ; int xstrrev(char *); int main(int argc, char *argv[]) { int res=0; char *str=argv[1]; if (argc < 2 ) { printf(\"Invalid argumentn\"); printf(\"Usage: %s <string> n\", argv[0]); return -1; } printf(\"Input String: %sn\", str); res = xstrrev(str); printf(\"Reverse String : %sn\", str); return 0; } void swap(char *s, char *d) { char t; t = *s; *s= *d; *d = t; } int xstrrev(char *str) { int count=0; char *ptr=str; char *rptr=str; for(count=0; *rptr != 0; rptr++, count++) /* empty */; rptr--; while (ptr < rptr ) { swap(ptr++,rptr--); } return 0; }","title":"String reverse"},{"location":"data-structure/string-reverse/#program-to-reverse-input-string","text":"SEPTEMBER 29,2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* file: strrev.c */ /* Program to reverse string */ #include <stdio.h> /* Declarations */ void swap(char *s, char *d) ; int xstrrev(char *); int main(int argc, char *argv[]) { int res=0; char *str=argv[1]; if (argc < 2 ) { printf(\"Invalid argumentn\"); printf(\"Usage: %s <string> n\", argv[0]); return -1; } printf(\"Input String: %sn\", str); res = xstrrev(str); printf(\"Reverse String : %sn\", str); return 0; } void swap(char *s, char *d) { char t; t = *s; *s= *d; *d = t; } int xstrrev(char *str) { int count=0; char *ptr=str; char *rptr=str; for(count=0; *rptr != 0; rptr++, count++) /* empty */; rptr--; while (ptr < rptr ) { swap(ptr++,rptr--); } return 0; }","title":"Program to reverse input string"},{"location":"data-structure/swap-two-number-without-using-temporary-variable/","text":"Program to swap two number without using temporary variable SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* file: swap_number.c */ include / Swap a number without using temp variable / void swap(int a, int b) { a ^= b; b ^= a; a ^= b; } / main routine / int main(int argc, char *argv[]) { int x=5, y =8; printf(\"nEnter 1st Number: \"); scanf(\"%d\", &x); printf(\"nEnter 2nd Number: \"); scanf(\"%d\", &y); printf(\"Before: x=%d, y=%d\\n\", x,y); swap(&x,&y); printf(\"After : x=%d, y=%d\\n\", x,y); return 0; } ### Compilation Steps: $ gcc -o swap_number swap_number.c ### Output: Enter 1st Number:34 Enter 2nd Number:43 Before: x=34, y=43 After : x=43, y=34 ```","title":"Swap two number without using temporary variable"},{"location":"data-structure/swap-two-number-without-using-temporary-variable/#program-to-swap-two-number-without-using-temporary-variable","text":"SEPTEMBER 29, 2018 ~ ADMIN@EMBEDDEDPROGRAMS.COM /* file: swap_number.c */","title":"Program to swap two number without using temporary variable"},{"location":"data-structure/swap-two-number-without-using-temporary-variable/#include","text":"/ Swap a number without using temp variable / void swap(int a, int b) { a ^= b; b ^= a; a ^= b; } / main routine / int main(int argc, char *argv[]) { int x=5, y =8; printf(\"nEnter 1st Number: \"); scanf(\"%d\", &x); printf(\"nEnter 2nd Number: \"); scanf(\"%d\", &y); printf(\"Before: x=%d, y=%d\\n\", x,y); swap(&x,&y); printf(\"After : x=%d, y=%d\\n\", x,y); return 0; } ### Compilation Steps: $ gcc -o swap_number swap_number.c ### Output: Enter 1st Number:34 Enter 2nd Number:43 Before: x=34, y=43 After : x=43, y=34 ```","title":"include "},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/","text":"Best Questions for Embedded Programmers - by Sanjay Ahuja Interview Questions: What are static variables? What are volatile variables? What do you mean by const keyword ? What is interrupt latency? How you can optimize it? What is size of character, integer, integer pointer, character pointer? What is NULL pointer and what is its use? What is void pointer and what is its use? What is ISR? What is return type of ISR? Can we use any function inside ISR? 12.Can we use printf inside ISR? Can we put breakpoint inside ISR? How to decide whether given processor is using little endian format or big endian format ? What is Top half & bottom half of a kernel? Difference between RISC and CISC processor. What is RTOS? What is the difference between hard real-time and soft real-time OS? What type of scheduling is there in RTOS? What is priority inversion? What is priority inheritance? How many types of IPC mechanism you know? What is semaphore? What is spin lock? What is difference between binary semaphore and mutex? What is virtual memory? What is kernel paging? Can structures be passed to the functions by value? Why cannot arrays be passed by values to functions? Advantages and disadvantages of using macro and inline functions? What happens when recursion functions are declared inline? #define cat(x,y) x\\#\\#y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why? Can you have constant volatile variable? Yes, you can have a volatile pointer? ++\\*ip increments what? it increments what ip points to Operations involving unsigned and signed --- unsigned will be converted to signed malloc(sizeof(0)) will return --- valid pointer c main() {fork();fork();fork();printf(\\\"hello world\\\"); } --- will print 8 times. Array of pts to functions --- void (*fptr[10])() Which way of writing infinite loops is more efficient than others? there are 3ways. Who to know whether system uses big endian or little endian format and how to convert among them? What is forward reference w.r.t. pointers in c? How is generic list manipulation function written which accepts elements of any kind? 43.What is the difference between embedded systems and the system in which RTOS is running? 44.How can you define a structure with bit field members? How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte? Which parameters decide the size of data type for a processor ? 47.What is job of preprocessor, compiler, assembler and linker ? 48.What is the difference between static linking and dynamic linking ? 49.How to implement a WD timer in software ? Answers (by Nigel Jones) to some of the questions. Preprocessor Using the #define statement, how would you declare a manifest constant that returns the number of seconds in a year? Disregard leap years in your answer. #define SECONDS\\_PER\\_YEAR (60 \\* 60 \\* 24 \\* 365)UL The purpose of this question is to test the following: Basic knowledge of the #define syntax (for example, no semi-colon at the end, the need to parenthesize, and so on) An understanding that the pre-processor will evaluate constant expressions for you. Thus, it is clearer, and penalty-free, to spell out how you are calculating the number of seconds in a year, rather than actually doing the calculation yourself A realization that the expression will overflow an integer argument on a 16-bit machine- hence the need for the L, telling the compiler to treat the variable as a Long As a bonus, if you modified the expression with a UL (indicating unsigned long), then you are off to a great start. And remember, first impressions count Write the \"standard\" MIN macro-that is, a macro that takes two arguments and returns the smaller of the two arguments. #define MIN(A,B) ((A) < = (B) ? (A) : (B)) The purpose of this question is to test the following: Basic knowledge of the #define directive as used in macros. This is important because until the inline operator becomes part of standard C, macros are the only portable way of generating inline code. Inline code is often necessary in embedded systems in order to achieve the required performance level Knowledge of the ternary conditional operator. This operator exists in C because it allows the compiler to produce more optimal code than an if-then-else sequence. Given that performance is normally an issue in embedded systems, knowledge and use of this construct is important Understanding of the need to very carefully parenthesize arguments to macros I also use this question to start a discussion on the side effects of macros, for example, what happens when you write code such as: least = MIN(*p++, b); What is the purpose of the preprocessor directive #error? Either you know the answer to this, or you don\\'t. If you don\\'t, see Reference 1. This question is useful for differentiating between normal folks and the nerds. Only the nerds actually read the appendices of C textbooks to find out about such things. Of course, if you aren\\'t looking for a nerd, the candidate better hope she doesn\\'t know the answer. Infinite loops Infinite loops often arise in embedded systems. How does you code an infinite loop in C? There are several solutions to this question. My preferred solution is: **while(1)** **{** **}** Many programmers seem to prefer: **for(;;)** **{** **}** This construct puzzles me because the syntax doesn\\'t exactly spell out what\\'s going on. Thus, if a candidate gives this as a solution, I\\'ll use it as an opportunity to explore their rationale for doing so. If their answer is basically, \\\"I was taught to do it this way and I haven\\'t thought about it since,\\\" it tells me something (bad) about them. A third solution is to use a goto : **Loop:** **\\...** **goto Loop;** Candidates who propose this are either assembly language programmers (which is probably good), or else they are closet BASIC/FORTRAN programmers looking to get into a new field. Data declarations Using the variable a, give definitions for the following: a) An integer b) A pointer to an integer c) A pointer to a pointer to an integer d) An array of 10 integers e) An array of 10 pointers to integers f) A pointer to an array of 10 integers g) A pointer to a function that takes an integer as an argument and > returns an integer h) An array of ten pointers to functions that take an integer argument and return an integer The answers are: a) int a; // An integer b) int *a; // A pointer to an integer c) int **a; // A pointer to a pointer to an integer d) int a[10]; // An array of 10 integers e) int *a[10]; // An array of 10 pointers to integers f) int (*a)[10]; // A pointer to an array of 10 integers g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer People often claim that a couple of these are the sorts of thing that one looks up in textbooks- and I agree. While writing this article, I consulted textbooks to ensure the syntax was correct. However, I expect to be asked this question (or something close to it) when I\\'m being interviewed. Consequently, I make sure I know the answers, at least for the few hours of the interview. Candidates who don\\'t know all the answers (or at least most of them) are simply unprepared for the interview. If they can\\'t be prepared for the interview, what will they be prepared for? Static What are the uses of the keyword static? This simple question is rarely answered completely. Static has three distinct uses in C: A variable declared static within the body of a function maintains its value between function invocations A variable declared static within a module, (but outside the body of a function) is accessible by all functions within that module. It is not accessible by functions within any other module. That is, it is a localized global Functions declared static within a module may only be called by other functions within that module. That is, the scope of the function is localized to the module within which it is declared Most candidates get the first part correct. A reasonable number get the second part correct, while a pitiful number understand the third answer. This is a serious weakness in a candidate, since he obviously doesn't understand the importance and benefits of localizing the scope of both data and code. Const What does the keyword const mean? As soon as the interviewee says \"const means constant,\" I know I'm dealing with an amateur. Dan Saks has exhaustively covered const in the last year, such that every reader of ESP should be extremely familiar with what const can and cannot do for you. If you haven't been reading that column, suffice it to say that const means \"read-only.\" Although this answer doesn't really do the subject justice, I'd accept it as a correct answer. (If you want the detailed answer, read Saks' columns-carefully!) If the candidate gets the answer correct, I'll ask him these supplemental questions: What do the following declarations mean? const int a; int const a; const int *a; int * const a; int const * a const; The first two mean the same thing, namely a is a const (read-only) integer. The third means a is a pointer to a const integer (that is, the integer isn\\'t modifiable, but the pointer is). The fourth declares a to be a const pointer to an integer (that is, the integer pointed to by a is modifiable, but the pointer is not). The final declaration declares a to be a const pointer to a const integer (that is, neither the integer pointed to by a, nor the pointer itself may be modified). If the candidate correctly answers these questions, I\\'ll be impressed. Incidentally, you might wonder why I put so much emphasis on const, since it is easy to write a correctly functioning program without ever using it. I have several reasons: - The use of const conveys some very useful information to someone reading your code. In effect, declaring a parameter const tells the user about its intended usage. If you spend a lot of time cleaning up the mess left by other people, you\\'ll quickly learn to appreciate this extra piece of information. (Of course, programmers who use const , rarely leave a mess for others to clean up.) - const has the potential for generating tighter code by giving the optimizer some additional information - Code that uses const liberally is inherently protected by the compiler against inadvertent coding constructs that result in parameters being changed that should not be. In short, they tend to have fewer bugs Volatile What does the keyword volatile mean? Give three different examples of its use. A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. In particular, the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. Examples of volatile variables are: Hardware registers in peripherals (for example, status registers) Non-automatic variables referenced within an interrupt service routine Variables shared by multiple tasks in a multi-threaded application Candidates who don't know the answer to this question aren't hired. I consider this the most fundamental question that distinguishes between a C programmer and an embedded systems programmer. Embedded folks deal with hardware, interrupts, RTOSes, and the like. All of these require volatile variables. Failure to understand the concept of volatile will lead to disaster. On the (dubious) assumption that the interviewee gets this question correct, I like to probe a little deeper to see if they really understand the full significance of volatile . In particular, I'll ask them the following additional questions: Can a parameter be both const and volatile ? Explain. Can a pointer be volatile ? Explain. What's wrong with the following function?: int square(volatile int *ptr) { return *ptr * *ptr; } The answers are as follows: Yes. An example is a read-only status register. It is volatile because it can change unexpectedly. It is const because the program should not attempt to modify it Yes, although this is not very common. An example is when an interrupt service routine modifies a pointer to a buffer This one is wicked. The intent of the code is to return the square of the value pointed to by *ptr . However, since *ptr points to a volatile parameter, the compiler will generate code that looks something like this: int square(volatile int \\*ptr) { int a,b; a = *ptr; b = *ptr; return a * b; } Because it's possible for the value of *ptr to change unexpectedly, it is possible for a and b to be different. Consequently, this code could return a number that is not a square! The correct way to code this is: long square(volatile int \\*ptr) { int a; a = *ptr; return a * a; } Bit manipulation Embedded systems always require the user to manipulate bits in registers or variables. Given an integer variable a, write two code fragments. The first should set bit 3 of a. The second should clear bit 3 of a. In both cases, the remaining bits should be unmodified. These are the three basic responses to this question: - No idea. The interviewee cannot have done any embedded systems work - Use bit fields. Bit fields are right up there with trigraphs as the most brain-dead portion of C. Bit fields are inherently non-portable across compilers, and as such guarantee that your code is not reusable. I recently had the misfortune to look at a driver written by Infineon for one of their more complex communications chips. It used bit fields and was completely useless because my compiler implemented the bit fields the other way around. The moral: never let a non-embedded person anywhere near a real piece of hardware! - Use #defines and bit masks. This is a highly portable method and is the one that should be used. My optimal solution to this problem would be: #define BIT3 (0x1 <<3) static int a; void set_bit3(void) { a |= BIT3; } void clear_bit3(void) { a &= ~BIT3; } Some people prefer to define a mask together with manifest constants for the set and clear values. This is also acceptable. The element that I'm looking for is the use of manifest constants, together with the |= and &= ~ constructs Accessing fixed memory locations Embedded systems are often characterized by requiring the programmer to access a specific memory location. On a certain project it is required to set an integer variable at the absolute address 0x67a9 to the value 0xaa55. The compiler is a pure ANSI compiler. Write code to accomplish this task. This problem tests whether you know that it is legal to typecast an integer to a pointer in order to access an absolute location. The exact syntax varies depending upon one\\'s style. However, I would typically be looking for something like this: int *ptr; ptr = (int *)0x67a9; *ptr = 0xaa55; A more obscure approach is: *(int * const)(0x67a9) = 0xaa55; Even if your taste runs more to the second solution, I suggest the first solution when you are in an interview situation. Interrupts Interrupts are an important part of embedded systems. Consequently, many compiler vendors offer an extension to standard C to support interrupts. Typically, this new keyword is interrupt. The following code uses interrupt to define an interrupt service routine (ISR). Comment on the code. interrupt double compute_area (double radius) { double area = PI * radius * radius; printf(\"\\nArea = %f\", area); return area;* } This function has so much wrong with it, it's hard to know where to start: - ISRs cannot return a value. If you don't understand this, you aren't hired - ISRs cannot be passed parameters. See the first item for your employment prospects if you missed this - On many processors/compilers, floating-point operations are not necessarily re-entrant. In some cases one needs to stack additional registers. In other cases, one simply cannot do floating point in an ISR. Furthermore, given that a general rule of thumb is that ISRs should be short and sweet, one wonders about the wisdom of doing floating-point math here - In a vein similar to the third point, printf() often has problems with reentrancy and performance. If you missed points three and four, I wouldn't be too hard on you. Needless to say, if you got these last two points, your employment prospects are looking better and better Code examples What does the following code output and why? void foo(void) { unsigned int a = 6; int b = -20; (a+b > 6) ? puts(\"> 6\") : puts(\"<=6\"); } This question tests whether you understand the integer promotion rules in C-an area that I find is very poorly understood by many developers. Anyway, the answer is that this outputs \"> 6.\" The reason for this is that expressions involving signed and unsigned types have all operands promoted to unsigned types. Thus \ufffdcomes a very large positive integer and the expression evaluates to greater than 6. This is a very important point in embedded systems where unsigned data types should be used frequently (see Reference 2). If you get this one wrong, you are perilously close to not getting the job. Comment on the following code fragment. unsigned int zero = 0; unsigned int compzero = 0xFFFF; /* 1's complement of zero */ On machines where an int is not 16 bits, this will be incorrect. It should be coded: *unsigned int compzero = ~0; This question really gets to whether the candidate understands the importance of word length on a computer. In my experience, good embedded programmers are critically aware of the underlying hardware and its limitations, whereas computer programmers tend to dismiss the hardware as a necessary annoyance. By this stage, candidates are either completely demoralized-or they're on a roll and having a good time. If it\\'s obvious that the candidate isn\\'t very good, then the test is terminated at this point. However, if the candidate is doing well, then I throw in these supplemental questions. These questions are hard, and I expect that only the very best candidates will do well on them. In posing these questions, I'm looking more at the way the candidate tackles the problems, rather than the answers. Anyway, have fun... Dynamic memory allocation Although not as common as in non-embedded computers, embedded systems do still dynamically allocate memory from the heap. What are the problems with dynamic memory allocation in embedded systems? Here, I expect the user to mention memory fragmentation, problems with garbage collection, variable execution time, and so on. This topic has been covered extensively in ESP , mainly by P.J. Plauger. His explanations are far more insightful than anything I could offer here, so go and read those back issues! Having lulled the candidate into a sense of false security, I then offer up this tidbit: What does the following code fragment output and why? char *ptr; if ((ptr = (char *)malloc(0)) == NULL) else puts(\"Got a null pointer\"); puts(\"Got a valid pointer\"); This is a fun question. I stumbled across this only recently when a colleague of mine inadvertently passed a value of 0 to malloc and got back a valid pointer! That is, the above code will output \"Got a valid pointer.\" I use this to start a discussion on whether the interviewee thinks this is the correct thing for the library routine to do. Getting the right answer here is not nearly as important as the way you approach the problem and the rationale for your decision. Typedef Typedef is frequently used in C to declare synonyms for pre-existing data types. It is also possible to use the preprocessor to do something similar. For instance, consider the following code fragment: #define dPS struct s * typedef struct s * tPS; The intent in both cases is to define dPS and tPS *to be pointers to structure s. Which method, if any, is preferred and why? * This is a very subtle question, and anyone who gets it right (for the right reason) is to be congratulated or condemned (\"get a life\" springs to mind). The answer is the typedef is preferred. Consider the declarations: dPS p1,p2; tPS p3,p4; The first expands to: struct s* p1, p2; which defines p1 to be a pointer to the structure and p2 to be an actual structure, which is probably not what you wanted. The second example correctly defines p3 and p4 to be pointers. Obscure syntax C allows some appalling constructs. Is this construct legal, and if so what does this code do? int a = 5, b = 7, c; c = a+++b; This question is intended to be a lighthearted end to the quiz, as, believe it or not, this is perfectly legal syntax. The question is how does the compiler treat it? Those poor compiler writers actually debated this issue, and came up with the \"maximum munch\" rule, which stipulates that the compiler should bite off as big (and legal) a chunk as it can. Hence, this code is treated as: c = a++ + b; Thus, after this code is executed, a = 6, b = 7, and c = 12. If you knew the answer, or guessed correctly, well done. If you didn't know the answer then I wouldn't consider this to be a problem. I find the greatest benefit of this question is that it is good for stimulating questions on coding styles, the value of code reviews, and the benefits of using lint.","title":"Best interview questions for embedded programs by sanjay ahuja"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#best-questions-for-embedded-programmers-by-sanjay-ahuja","text":"","title":"Best Questions for Embedded Programmers - by Sanjay Ahuja"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#interview-questions","text":"What are static variables? What are volatile variables? What do you mean by const keyword ? What is interrupt latency? How you can optimize it? What is size of character, integer, integer pointer, character pointer? What is NULL pointer and what is its use? What is void pointer and what is its use? What is ISR? What is return type of ISR? Can we use any function inside ISR? 12.Can we use printf inside ISR? Can we put breakpoint inside ISR? How to decide whether given processor is using little endian format or big endian format ? What is Top half & bottom half of a kernel? Difference between RISC and CISC processor. What is RTOS? What is the difference between hard real-time and soft real-time OS? What type of scheduling is there in RTOS? What is priority inversion? What is priority inheritance? How many types of IPC mechanism you know? What is semaphore? What is spin lock? What is difference between binary semaphore and mutex? What is virtual memory? What is kernel paging? Can structures be passed to the functions by value? Why cannot arrays be passed by values to functions? Advantages and disadvantages of using macro and inline functions? What happens when recursion functions are declared inline? #define cat(x,y) x\\#\\#y concatenates x to y. But cat(cat(1,2),3) does not expand but gives preprocessor warning. Why? Can you have constant volatile variable? Yes, you can have a volatile pointer? ++\\*ip increments what? it increments what ip points to Operations involving unsigned and signed --- unsigned will be converted to signed malloc(sizeof(0)) will return --- valid pointer c main() {fork();fork();fork();printf(\\\"hello world\\\"); } --- will print 8 times. Array of pts to functions --- void (*fptr[10])() Which way of writing infinite loops is more efficient than others? there are 3ways. Who to know whether system uses big endian or little endian format and how to convert among them? What is forward reference w.r.t. pointers in c? How is generic list manipulation function written which accepts elements of any kind? 43.What is the difference between embedded systems and the system in which RTOS is running? 44.How can you define a structure with bit field members? How do you write a function which takes 2 arguments - a byte and a field in the byte and returns the value of the field in that byte? Which parameters decide the size of data type for a processor ? 47.What is job of preprocessor, compiler, assembler and linker ? 48.What is the difference between static linking and dynamic linking ? 49.How to implement a WD timer in software ? Answers (by Nigel Jones) to some of the questions. Preprocessor Using the #define statement, how would you declare a manifest constant that returns the number of seconds in a year? Disregard leap years in your answer. #define SECONDS\\_PER\\_YEAR (60 \\* 60 \\* 24 \\* 365)UL The purpose of this question is to test the following: Basic knowledge of the #define syntax (for example, no semi-colon at the end, the need to parenthesize, and so on) An understanding that the pre-processor will evaluate constant expressions for you. Thus, it is clearer, and penalty-free, to spell out how you are calculating the number of seconds in a year, rather than actually doing the calculation yourself A realization that the expression will overflow an integer argument on a 16-bit machine- hence the need for the L, telling the compiler to treat the variable as a Long As a bonus, if you modified the expression with a UL (indicating unsigned long), then you are off to a great start. And remember, first impressions count Write the \"standard\" MIN macro-that is, a macro that takes two arguments and returns the smaller of the two arguments. #define MIN(A,B) ((A) < = (B) ? (A) : (B)) The purpose of this question is to test the following: Basic knowledge of the #define directive as used in macros. This is important because until the inline operator becomes part of standard C, macros are the only portable way of generating inline code. Inline code is often necessary in embedded systems in order to achieve the required performance level Knowledge of the ternary conditional operator. This operator exists in C because it allows the compiler to produce more optimal code than an if-then-else sequence. Given that performance is normally an issue in embedded systems, knowledge and use of this construct is important Understanding of the need to very carefully parenthesize arguments to macros I also use this question to start a discussion on the side effects of macros, for example, what happens when you write code such as: least = MIN(*p++, b); What is the purpose of the preprocessor directive #error? Either you know the answer to this, or you don\\'t. If you don\\'t, see Reference 1. This question is useful for differentiating between normal folks and the nerds. Only the nerds actually read the appendices of C textbooks to find out about such things. Of course, if you aren\\'t looking for a nerd, the candidate better hope she doesn\\'t know the answer.","title":"Interview Questions:"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#infinite-loops","text":"Infinite loops often arise in embedded systems. How does you code an infinite loop in C? There are several solutions to this question. My preferred solution is: **while(1)** **{** **}** Many programmers seem to prefer: **for(;;)** **{** **}** This construct puzzles me because the syntax doesn\\'t exactly spell out what\\'s going on. Thus, if a candidate gives this as a solution, I\\'ll use it as an opportunity to explore their rationale for doing so. If their answer is basically, \\\"I was taught to do it this way and I haven\\'t thought about it since,\\\" it tells me something (bad) about them. A third solution is to use a goto : **Loop:** **\\...** **goto Loop;** Candidates who propose this are either assembly language programmers (which is probably good), or else they are closet BASIC/FORTRAN programmers looking to get into a new field.","title":"Infinite loops"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#data-declarations","text":"Using the variable a, give definitions for the following: a) An integer b) A pointer to an integer c) A pointer to a pointer to an integer d) An array of 10 integers e) An array of 10 pointers to integers f) A pointer to an array of 10 integers g) A pointer to a function that takes an integer as an argument and > returns an integer h) An array of ten pointers to functions that take an integer argument and return an integer The answers are: a) int a; // An integer b) int *a; // A pointer to an integer c) int **a; // A pointer to a pointer to an integer d) int a[10]; // An array of 10 integers e) int *a[10]; // An array of 10 pointers to integers f) int (*a)[10]; // A pointer to an array of 10 integers g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer People often claim that a couple of these are the sorts of thing that one looks up in textbooks- and I agree. While writing this article, I consulted textbooks to ensure the syntax was correct. However, I expect to be asked this question (or something close to it) when I\\'m being interviewed. Consequently, I make sure I know the answers, at least for the few hours of the interview. Candidates who don\\'t know all the answers (or at least most of them) are simply unprepared for the interview. If they can\\'t be prepared for the interview, what will they be prepared for?","title":"Data declarations"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#static","text":"What are the uses of the keyword static? This simple question is rarely answered completely. Static has three distinct uses in C: A variable declared static within the body of a function maintains its value between function invocations A variable declared static within a module, (but outside the body of a function) is accessible by all functions within that module. It is not accessible by functions within any other module. That is, it is a localized global Functions declared static within a module may only be called by other functions within that module. That is, the scope of the function is localized to the module within which it is declared Most candidates get the first part correct. A reasonable number get the second part correct, while a pitiful number understand the third answer. This is a serious weakness in a candidate, since he obviously doesn't understand the importance and benefits of localizing the scope of both data and code.","title":"Static"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#const","text":"What does the keyword const mean? As soon as the interviewee says \"const means constant,\" I know I'm dealing with an amateur. Dan Saks has exhaustively covered const in the last year, such that every reader of ESP should be extremely familiar with what const can and cannot do for you. If you haven't been reading that column, suffice it to say that const means \"read-only.\" Although this answer doesn't really do the subject justice, I'd accept it as a correct answer. (If you want the detailed answer, read Saks' columns-carefully!) If the candidate gets the answer correct, I'll ask him these supplemental questions: What do the following declarations mean? const int a; int const a; const int *a; int * const a; int const * a const; The first two mean the same thing, namely a is a const (read-only) integer. The third means a is a pointer to a const integer (that is, the integer isn\\'t modifiable, but the pointer is). The fourth declares a to be a const pointer to an integer (that is, the integer pointed to by a is modifiable, but the pointer is not). The final declaration declares a to be a const pointer to a const integer (that is, neither the integer pointed to by a, nor the pointer itself may be modified). If the candidate correctly answers these questions, I\\'ll be impressed. Incidentally, you might wonder why I put so much emphasis on const, since it is easy to write a correctly functioning program without ever using it. I have several reasons: - The use of const conveys some very useful information to someone reading your code. In effect, declaring a parameter const tells the user about its intended usage. If you spend a lot of time cleaning up the mess left by other people, you\\'ll quickly learn to appreciate this extra piece of information. (Of course, programmers who use const , rarely leave a mess for others to clean up.) - const has the potential for generating tighter code by giving the optimizer some additional information - Code that uses const liberally is inherently protected by the compiler against inadvertent coding constructs that result in parameters being changed that should not be. In short, they tend to have fewer bugs","title":"Const"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#volatile","text":"What does the keyword volatile mean? Give three different examples of its use. A volatile variable is one that can change unexpectedly. Consequently, the compiler can make no assumptions about the value of the variable. In particular, the optimizer must be careful to reload the variable every time it is used instead of holding a copy in a register. Examples of volatile variables are: Hardware registers in peripherals (for example, status registers) Non-automatic variables referenced within an interrupt service routine Variables shared by multiple tasks in a multi-threaded application Candidates who don't know the answer to this question aren't hired. I consider this the most fundamental question that distinguishes between a C programmer and an embedded systems programmer. Embedded folks deal with hardware, interrupts, RTOSes, and the like. All of these require volatile variables. Failure to understand the concept of volatile will lead to disaster. On the (dubious) assumption that the interviewee gets this question correct, I like to probe a little deeper to see if they really understand the full significance of volatile . In particular, I'll ask them the following additional questions: Can a parameter be both const and volatile ? Explain. Can a pointer be volatile ? Explain. What's wrong with the following function?: int square(volatile int *ptr) { return *ptr * *ptr; } The answers are as follows: Yes. An example is a read-only status register. It is volatile because it can change unexpectedly. It is const because the program should not attempt to modify it Yes, although this is not very common. An example is when an interrupt service routine modifies a pointer to a buffer This one is wicked. The intent of the code is to return the square of the value pointed to by *ptr . However, since *ptr points to a volatile parameter, the compiler will generate code that looks something like this: int square(volatile int \\*ptr) { int a,b; a = *ptr; b = *ptr; return a * b; } Because it's possible for the value of *ptr to change unexpectedly, it is possible for a and b to be different. Consequently, this code could return a number that is not a square! The correct way to code this is: long square(volatile int \\*ptr) { int a; a = *ptr; return a * a; }","title":"Volatile"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#bit-manipulation","text":"Embedded systems always require the user to manipulate bits in registers or variables. Given an integer variable a, write two code fragments. The first should set bit 3 of a. The second should clear bit 3 of a. In both cases, the remaining bits should be unmodified. These are the three basic responses to this question: - No idea. The interviewee cannot have done any embedded systems work - Use bit fields. Bit fields are right up there with trigraphs as the most brain-dead portion of C. Bit fields are inherently non-portable across compilers, and as such guarantee that your code is not reusable. I recently had the misfortune to look at a driver written by Infineon for one of their more complex communications chips. It used bit fields and was completely useless because my compiler implemented the bit fields the other way around. The moral: never let a non-embedded person anywhere near a real piece of hardware! - Use #defines and bit masks. This is a highly portable method and is the one that should be used. My optimal solution to this problem would be: #define BIT3 (0x1 <<3) static int a; void set_bit3(void) { a |= BIT3; } void clear_bit3(void) { a &= ~BIT3; } Some people prefer to define a mask together with manifest constants for the set and clear values. This is also acceptable. The element that I'm looking for is the use of manifest constants, together with the |= and &= ~ constructs","title":"Bit manipulation"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#accessing-fixed-memory-locations","text":"Embedded systems are often characterized by requiring the programmer to access a specific memory location. On a certain project it is required to set an integer variable at the absolute address 0x67a9 to the value 0xaa55. The compiler is a pure ANSI compiler. Write code to accomplish this task. This problem tests whether you know that it is legal to typecast an integer to a pointer in order to access an absolute location. The exact syntax varies depending upon one\\'s style. However, I would typically be looking for something like this: int *ptr; ptr = (int *)0x67a9; *ptr = 0xaa55; A more obscure approach is: *(int * const)(0x67a9) = 0xaa55; Even if your taste runs more to the second solution, I suggest the first solution when you are in an interview situation.","title":"Accessing fixed memory locations"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#interrupts","text":"Interrupts are an important part of embedded systems. Consequently, many compiler vendors offer an extension to standard C to support interrupts. Typically, this new keyword is interrupt. The following code uses interrupt to define an interrupt service routine (ISR). Comment on the code. interrupt double compute_area (double radius) { double area = PI * radius * radius; printf(\"\\nArea = %f\", area); return area;* } This function has so much wrong with it, it's hard to know where to start: - ISRs cannot return a value. If you don't understand this, you aren't hired - ISRs cannot be passed parameters. See the first item for your employment prospects if you missed this - On many processors/compilers, floating-point operations are not necessarily re-entrant. In some cases one needs to stack additional registers. In other cases, one simply cannot do floating point in an ISR. Furthermore, given that a general rule of thumb is that ISRs should be short and sweet, one wonders about the wisdom of doing floating-point math here - In a vein similar to the third point, printf() often has problems with reentrancy and performance. If you missed points three and four, I wouldn't be too hard on you. Needless to say, if you got these last two points, your employment prospects are looking better and better","title":"Interrupts"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#code-examples","text":"What does the following code output and why? void foo(void) { unsigned int a = 6; int b = -20; (a+b > 6) ? puts(\"> 6\") : puts(\"<=6\"); } This question tests whether you understand the integer promotion rules in C-an area that I find is very poorly understood by many developers. Anyway, the answer is that this outputs \"> 6.\" The reason for this is that expressions involving signed and unsigned types have all operands promoted to unsigned types. Thus \ufffdcomes a very large positive integer and the expression evaluates to greater than 6. This is a very important point in embedded systems where unsigned data types should be used frequently (see Reference 2). If you get this one wrong, you are perilously close to not getting the job. Comment on the following code fragment. unsigned int zero = 0; unsigned int compzero = 0xFFFF; /* 1's complement of zero */ On machines where an int is not 16 bits, this will be incorrect. It should be coded: *unsigned int compzero = ~0; This question really gets to whether the candidate understands the importance of word length on a computer. In my experience, good embedded programmers are critically aware of the underlying hardware and its limitations, whereas computer programmers tend to dismiss the hardware as a necessary annoyance. By this stage, candidates are either completely demoralized-or they're on a roll and having a good time. If it\\'s obvious that the candidate isn\\'t very good, then the test is terminated at this point. However, if the candidate is doing well, then I throw in these supplemental questions. These questions are hard, and I expect that only the very best candidates will do well on them. In posing these questions, I'm looking more at the way the candidate tackles the problems, rather than the answers. Anyway, have fun...","title":"Code examples"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#dynamic-memory-allocation","text":"Although not as common as in non-embedded computers, embedded systems do still dynamically allocate memory from the heap. What are the problems with dynamic memory allocation in embedded systems? Here, I expect the user to mention memory fragmentation, problems with garbage collection, variable execution time, and so on. This topic has been covered extensively in ESP , mainly by P.J. Plauger. His explanations are far more insightful than anything I could offer here, so go and read those back issues! Having lulled the candidate into a sense of false security, I then offer up this tidbit: What does the following code fragment output and why? char *ptr; if ((ptr = (char *)malloc(0)) == NULL) else puts(\"Got a null pointer\"); puts(\"Got a valid pointer\"); This is a fun question. I stumbled across this only recently when a colleague of mine inadvertently passed a value of 0 to malloc and got back a valid pointer! That is, the above code will output \"Got a valid pointer.\" I use this to start a discussion on whether the interviewee thinks this is the correct thing for the library routine to do. Getting the right answer here is not nearly as important as the way you approach the problem and the rationale for your decision.","title":"Dynamic memory allocation"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#typedef","text":"Typedef is frequently used in C to declare synonyms for pre-existing data types. It is also possible to use the preprocessor to do something similar. For instance, consider the following code fragment: #define dPS struct s * typedef struct s * tPS; The intent in both cases is to define dPS and tPS *to be pointers to structure s. Which method, if any, is preferred and why? * This is a very subtle question, and anyone who gets it right (for the right reason) is to be congratulated or condemned (\"get a life\" springs to mind). The answer is the typedef is preferred. Consider the declarations: dPS p1,p2; tPS p3,p4; The first expands to: struct s* p1, p2; which defines p1 to be a pointer to the structure and p2 to be an actual structure, which is probably not what you wanted. The second example correctly defines p3 and p4 to be pointers.","title":"Typedef"},{"location":"interview-questions/best-interview-questions-for-embedded-programs-by-sanjay-ahuja/#obscure-syntax","text":"C allows some appalling constructs. Is this construct legal, and if so what does this code do? int a = 5, b = 7, c; c = a+++b; This question is intended to be a lighthearted end to the quiz, as, believe it or not, this is perfectly legal syntax. The question is how does the compiler treat it? Those poor compiler writers actually debated this issue, and came up with the \"maximum munch\" rule, which stipulates that the compiler should bite off as big (and legal) a chunk as it can. Hence, this code is treated as: c = a++ + b; Thus, after this code is executed, a = 6, b = 7, and c = 12. If you knew the answer, or guessed correctly, well done. If you didn't know the answer then I wouldn't consider this to be a problem. I find the greatest benefit of this question is that it is good for stimulating questions on coding styles, the value of code reviews, and the benefits of using lint.","title":"Obscure syntax"},{"location":"interview-questions/linux-interview-questions/","text":"Linux Kernel Interview Questions Linux Internals: What are the different IPC there in an OS? What is a semaphore? What is a mutex? What is the difference between semaphore and mutex? What are different types of CPU scheduling available? What is a preemption of a task? What is context switching? What is a round robin policy? What is the difference between pipes and named pipes? What are shared and Archive libraries? (YG) What is Priority Inversion ? How do data copy from kernel to user-space and vice versa ? What are ioctl calls ? How does it work ? Linux Device Drivers: What is a system call? What are the major system calls used in a typical device driver? What is the difference between char device and block device? Which system call is used in a specific in block device? What is a major number and what is a minor device? What is an ISR? How interrupts are handled in Linux? What all chips and devices have you worked with? Explain one? What is a virtual memory? For what purpose, mknod is used? What is MBR (Master Boot Record ) ? Bottom halves, Tasklets and softirq?","title":"Linux interview questions"},{"location":"interview-questions/linux-interview-questions/#linux-kernel-interview-questions","text":"","title":"Linux Kernel Interview Questions"},{"location":"interview-questions/linux-interview-questions/#linux-internals","text":"What are the different IPC there in an OS? What is a semaphore? What is a mutex? What is the difference between semaphore and mutex? What are different types of CPU scheduling available? What is a preemption of a task? What is context switching? What is a round robin policy? What is the difference between pipes and named pipes? What are shared and Archive libraries? (YG) What is Priority Inversion ? How do data copy from kernel to user-space and vice versa ? What are ioctl calls ? How does it work ?","title":"Linux Internals:"},{"location":"interview-questions/linux-interview-questions/#linux-device-drivers","text":"What is a system call? What are the major system calls used in a typical device driver? What is the difference between char device and block device? Which system call is used in a specific in block device? What is a major number and what is a minor device? What is an ISR? How interrupts are handled in Linux? What all chips and devices have you worked with? Explain one? What is a virtual memory? For what purpose, mknod is used? What is MBR (Master Boot Record ) ? Bottom halves, Tasklets and softirq?","title":"Linux Device Drivers:"},{"location":"interview-questions/system-programming-questions/","text":"System Programming Interview Questions What is a volatile variable ? What does the compiler do with > volatile variables ? Where volatile variables are used ? Can a pointer be volatile ? What is constant ? Can a variable be both volatile and constant ? Difference between 'const char *A' and 'char *const A' ? What is a void pointer and what is its use ? What are the preprocessors ? What are the advantages of macros over constants ? Is it possible to find the address of a variable of type 'register' > ? What is structure padding? Is there any way to tell the compiler to > avoid structure padding ? How do you find a loop in a linked list ? Can structures be passed as to the functions by value ? What are the minimum requirements to jump control from assembly > program to C program ? What are the different segments in the executable ? Describe > individual usage. What is the ELF file format ? Describe its different sections. How will you flash an image to the bare board ? Is it possible to execute code directly from NAND flash (without > loading it into RAM) ? What is the difference between a malloc() and a calloc() ? What malloc(0) will return ? How free() knows how much memory needs to be free ? What is big endian and little endian ? What things do you take care of in code to avoid endianness related > issues ? Write a program to find the endianness of a machine ? Write a program to convert from big endian to little endian ? Have you used the IPC mechanism ? Define individual pros and cons. What are the different synchronization mechanisms ? Where semaphores are used ? What is the difference between binary semaphore and mutex ? Where spin locks are used apart from the interrupt handler ? Is spin-lock available in uniprocessor system ? What are physical addresses and virtual addresses ? Why do we use > virtual addresses ? How will you map a physical address in Linux ? Are you aware of Linux Memory Management ? What is the difference between kmalloc() and vmalloc() ? Is it possible to allocate memory in Stack ? How ? What is a \"Flat Memory\" model ? What is virtualization ? How will you register an interrupt in Linux ? What will be the > return value of the interrupt handler ? What are top-half and bottom-half ? What are the things you care about while writing an interrupt > handler ? What is the difference between softirq, tasklet and workqueue ? Describe the interrupt handling mechanism in OS from the point > hardware generates an interrupt till its interrupt handler gets > called ? What is the difference between an exception and interrupt ? How will you allocate memory in the interrupt handler ? Which posix API is used to create a thread ? What is priority inversion ? What is SMP? How is synchronization done in the SMP system ? What is a system call ? Why is 'asm linkage' used ? How is the file system implemented in Linux OS ? How will you design/write a new BSP in Linux ? What is the difference between char and block drivers? How will you write a driver for a device? Design parameter..? How will you debug your driver ? Have you ever faced cache related issues ? If yes then how will you > resolve it ? Write a program to reverse a string. Write a macro to get offset of its variable (i.e. > OFFSET_OF(element, struct_t)) Write a program to count the number of set bits in a 32 bit integer. Write a program to insert a node in a doubly linked list. Write a program to make an address page alignment. Write a program in c which takes a variable number of parameters. Write a program for dynamic allocation of 2D arrays.","title":"System programming questions"},{"location":"interview-questions/system-programming-questions/#system-programming-interview-questions","text":"What is a volatile variable ? What does the compiler do with > volatile variables ? Where volatile variables are used ? Can a pointer be volatile ? What is constant ? Can a variable be both volatile and constant ? Difference between 'const char *A' and 'char *const A' ? What is a void pointer and what is its use ? What are the preprocessors ? What are the advantages of macros over constants ? Is it possible to find the address of a variable of type 'register' > ? What is structure padding? Is there any way to tell the compiler to > avoid structure padding ? How do you find a loop in a linked list ? Can structures be passed as to the functions by value ? What are the minimum requirements to jump control from assembly > program to C program ? What are the different segments in the executable ? Describe > individual usage. What is the ELF file format ? Describe its different sections. How will you flash an image to the bare board ? Is it possible to execute code directly from NAND flash (without > loading it into RAM) ? What is the difference between a malloc() and a calloc() ? What malloc(0) will return ? How free() knows how much memory needs to be free ? What is big endian and little endian ? What things do you take care of in code to avoid endianness related > issues ? Write a program to find the endianness of a machine ? Write a program to convert from big endian to little endian ? Have you used the IPC mechanism ? Define individual pros and cons. What are the different synchronization mechanisms ? Where semaphores are used ? What is the difference between binary semaphore and mutex ? Where spin locks are used apart from the interrupt handler ? Is spin-lock available in uniprocessor system ? What are physical addresses and virtual addresses ? Why do we use > virtual addresses ? How will you map a physical address in Linux ? Are you aware of Linux Memory Management ? What is the difference between kmalloc() and vmalloc() ? Is it possible to allocate memory in Stack ? How ? What is a \"Flat Memory\" model ? What is virtualization ? How will you register an interrupt in Linux ? What will be the > return value of the interrupt handler ? What are top-half and bottom-half ? What are the things you care about while writing an interrupt > handler ? What is the difference between softirq, tasklet and workqueue ? Describe the interrupt handling mechanism in OS from the point > hardware generates an interrupt till its interrupt handler gets > called ? What is the difference between an exception and interrupt ? How will you allocate memory in the interrupt handler ? Which posix API is used to create a thread ? What is priority inversion ? What is SMP? How is synchronization done in the SMP system ? What is a system call ? Why is 'asm linkage' used ? How is the file system implemented in Linux OS ? How will you design/write a new BSP in Linux ? What is the difference between char and block drivers? How will you write a driver for a device? Design parameter..? How will you debug your driver ? Have you ever faced cache related issues ? If yes then how will you > resolve it ? Write a program to reverse a string. Write a macro to get offset of its variable (i.e. > OFFSET_OF(element, struct_t)) Write a program to count the number of set bits in a 32 bit integer. Write a program to insert a node in a doubly linked list. Write a program to make an address page alignment. Write a program in c which takes a variable number of parameters. Write a program for dynamic allocation of 2D arrays.","title":"System Programming Interview Questions"},{"location":"tutorials/","text":"Technical Tutorials Story of a Boot Loader What makes a real RTOS? Spin Locks in Linux Journey of Interrupt","title":"Index"},{"location":"tutorials/#technical-tutorials","text":"Story of a Boot Loader What makes a real RTOS? Spin Locks in Linux Journey of Interrupt","title":"Technical Tutorials"},{"location":"tutorials/journey-of-interrupt/","text":"Journey of Interrupt SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM In embedded systems, the interrupt is the signal to the processor from the hardware device indicating device needs immediate attention. It's not only the hardware which can interrupt the CPU but software programs can also interrupt the CPU from its normal processing. In brief; the Interrupts are classified into below three categories: \u00a7 Software Interrupts \u00a7 Hardware Interrupts Software Interrupts: Software interrupts are results of execution of instruction, generally operating system uses software interrupts for implementations of system calls. Processors support a special assembly level instruction for handling the software interrupts. Architecture Instruction X86 INT ARM SWI PowerPC (PPC) SC Hardware Interrupts: Hardware interrupts are the interrupts generated by the hardware devices. . Hardware interrupts are further classified into internal and external interrupts. This classification comes into picture because latest processor have inbuilt devices within the System-On-Chip (SOC). The devices which reside inside the SOC are internal device and hardware device outside the SOC are external devices. Internal Hardware Interrupts External Hardware Interrupts For handling interrupt it doesn't matter whether it's internal or external, the processor handler both of them with same mechanism. Interrupt Handling: Interrupt makes processor to deviate from its normal processing and asked to serve the interrupt on higher priority. The processors save the current context and start its journey to process the interrupt. {width=\"6.010416666666667in\" height=\"3.3125in\"} The time taken between device generates an interrupt and acknowledges by corresponding interrupt handler is called the interrupt latency . {width=\"5.604166666666667in\" height=\"2.2291666666666665in\"} Exception vs. Interrupts: Before proceeding towards the interrupt, we should know the difference between interrupt and exception. In brief \"Exceptions are synchronous and Interrupts are asynchronous. \" Exceptions occurs due to execution of instruction, in PPC data abort, instruction abort are examples of exceptions. On the other hand, interrupts can occur anytime; processor has to take action immediately once interrupt has come. Interrupt Controller: Interrupt can come from different sources it could be a device which is embedded into SOC or may be connected outside SOC. So how processor know interrupt came from which source. To serve this purpose addition hardware is present called Interrupt controller. All the device interrupt lines are connected to the interrupt controller. Interrupt controller identifies from which IRQ line interrupt has occurred, but interrupt controller keep this information within itself. It immediately notifies the processor through dedicated exception that it got interrupt from the device. The hardware design for Interrupt controller is shown below: {width=\"6.5in\" height=\"3.59375in\"} During the initialization of the Interrupt controller it will assign the interrupt number to each input IRQ line and its priority, the high priority interrupt can go through the critical INT line (all based on Interrupt Controller configuration). In case of multiple CPU Interrupt controller has to be configured which interrupt goes to which CPU. Suppose device wants to send data to CPU, it first needs to generate an interrupt and interrupt controller find out from which IRQ line it got interrupt, if multiple IRQ generates an interrupt it process higher priority interrupt first, and send signal to CPU through INT (or CRIT_INT) line, and CPU raise an exception for the same. Now CPU Exception handler for the interrupt controller gets executed and it reads the interrupt number from the Interrupt Controller and acknowledges the interrupt within the Interrupt controller. CPU looks if any Interrupt Handler is register for the IRQ number, if so call the device Interrupt handler. Now the device interrupt handler will acknowledge the interrupt at device level and send the data to the CPU. Summary: Interrupt is a signal to the processor; it can be from external device or internal device within the SOC. Software interrupts are due to instruction execution while Hardware interrupts are from peripherals. Exceptions on the other hand are synchronous and Interrupts are asynchronous. Interrupt Controller is the hardware device used for managing the interrupt from the different sources; it decides the priority of different interrupts. References: http://en.wikipedia.org/wiki/Interrupt http://ecomputernotes.com/fundamental/input-output-and-memory/what-is-interrupt-types-of-interrupt","title":"Journey of interrupt"},{"location":"tutorials/journey-of-interrupt/#journey-of-interrupt","text":"SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM In embedded systems, the interrupt is the signal to the processor from the hardware device indicating device needs immediate attention. It's not only the hardware which can interrupt the CPU but software programs can also interrupt the CPU from its normal processing. In brief; the Interrupts are classified into below three categories: \u00a7 Software Interrupts \u00a7 Hardware Interrupts","title":"Journey of Interrupt"},{"location":"tutorials/journey-of-interrupt/#software-interrupts","text":"Software interrupts are results of execution of instruction, generally operating system uses software interrupts for implementations of system calls. Processors support a special assembly level instruction for handling the software interrupts. Architecture Instruction X86 INT ARM SWI PowerPC (PPC) SC","title":"Software Interrupts:"},{"location":"tutorials/journey-of-interrupt/#hardware-interrupts","text":"Hardware interrupts are the interrupts generated by the hardware devices. . Hardware interrupts are further classified into internal and external interrupts. This classification comes into picture because latest processor have inbuilt devices within the System-On-Chip (SOC). The devices which reside inside the SOC are internal device and hardware device outside the SOC are external devices. Internal Hardware Interrupts External Hardware Interrupts For handling interrupt it doesn't matter whether it's internal or external, the processor handler both of them with same mechanism.","title":"Hardware Interrupts:"},{"location":"tutorials/journey-of-interrupt/#interrupt-handling","text":"Interrupt makes processor to deviate from its normal processing and asked to serve the interrupt on higher priority. The processors save the current context and start its journey to process the interrupt. {width=\"6.010416666666667in\" height=\"3.3125in\"} The time taken between device generates an interrupt and acknowledges by corresponding interrupt handler is called the interrupt latency . {width=\"5.604166666666667in\" height=\"2.2291666666666665in\"}","title":"Interrupt Handling:"},{"location":"tutorials/journey-of-interrupt/#exception-vs-interrupts","text":"Before proceeding towards the interrupt, we should know the difference between interrupt and exception. In brief \"Exceptions are synchronous and Interrupts are asynchronous. \" Exceptions occurs due to execution of instruction, in PPC data abort, instruction abort are examples of exceptions. On the other hand, interrupts can occur anytime; processor has to take action immediately once interrupt has come.","title":"Exception vs. Interrupts:"},{"location":"tutorials/journey-of-interrupt/#interrupt-controller","text":"Interrupt can come from different sources it could be a device which is embedded into SOC or may be connected outside SOC. So how processor know interrupt came from which source. To serve this purpose addition hardware is present called Interrupt controller. All the device interrupt lines are connected to the interrupt controller. Interrupt controller identifies from which IRQ line interrupt has occurred, but interrupt controller keep this information within itself. It immediately notifies the processor through dedicated exception that it got interrupt from the device. The hardware design for Interrupt controller is shown below: {width=\"6.5in\" height=\"3.59375in\"} During the initialization of the Interrupt controller it will assign the interrupt number to each input IRQ line and its priority, the high priority interrupt can go through the critical INT line (all based on Interrupt Controller configuration). In case of multiple CPU Interrupt controller has to be configured which interrupt goes to which CPU. Suppose device wants to send data to CPU, it first needs to generate an interrupt and interrupt controller find out from which IRQ line it got interrupt, if multiple IRQ generates an interrupt it process higher priority interrupt first, and send signal to CPU through INT (or CRIT_INT) line, and CPU raise an exception for the same. Now CPU Exception handler for the interrupt controller gets executed and it reads the interrupt number from the Interrupt Controller and acknowledges the interrupt within the Interrupt controller. CPU looks if any Interrupt Handler is register for the IRQ number, if so call the device Interrupt handler. Now the device interrupt handler will acknowledge the interrupt at device level and send the data to the CPU.","title":"Interrupt Controller:"},{"location":"tutorials/journey-of-interrupt/#summary","text":"Interrupt is a signal to the processor; it can be from external device or internal device within the SOC. Software interrupts are due to instruction execution while Hardware interrupts are from peripherals. Exceptions on the other hand are synchronous and Interrupts are asynchronous. Interrupt Controller is the hardware device used for managing the interrupt from the different sources; it decides the priority of different interrupts.","title":"Summary:"},{"location":"tutorials/journey-of-interrupt/#references","text":"http://en.wikipedia.org/wiki/Interrupt http://ecomputernotes.com/fundamental/input-output-and-memory/what-is-interrupt-types-of-interrupt","title":"References:"},{"location":"tutorials/spin-locks-in-linux/","text":"Spin Locks in Linux SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM A spinlock is a mutual exclusion device that can have only two values: \"locked\" and \"unlocked.\" It is usually implemented as a single bit in an integer value. Code wishing to take out a particular lock tests the relevant bit. If the lock is available, the \"locked\" bit is set and the code continues into the critical section. If, instead, the lock has been taken by somebody else, the code goes into a tight loop where it repeatedly checks the lock until it becomes available. This loop is the \"spin\" part of a spinlock. Any time kernel code holds a spinlock, preemption is disabled on the relevant processor. Even uni-processor systems must disable preemption in this way to avoid race conditions. Below are the variants of spin locks: spin_lock() --- this acquires the spin lock, disables the preemption, but interrupts are enabled. --- disables preemption on local CPU --- acquire spin lock Usage: This is used when we do not share the critical section with interrupt handlers (i.e. only in process context). spin_lock_irq() --- this acquires the spin lock after disabling the preemption & interrupts on local CPU --- disable interrupt on local CPU --- disables preemption on local CPU --- acquire spin lock Usage: This is used when we share the critical section with Interrupt Service Routine. spin_lock_irqsave() --- same as spin_lock_irq() but saves the CPSR register in a local variable, so that we can restore it later on. --- save the CPSR into local variable (i.e. flag) --- disable interrupt on local CPU --- disables preemption on local CPU --- acquire spin lock Usage: This again is used when we share critical section with Interrupt Service Routine spin_lock_bh() --- disables software interrupts before taking the lock, but leaves hardware interrupts enabled. --- disable bottom-half on local CPU --- disables preemption on local CPU --- acquire spin lock Usage: This is used when we share the critical section with bottom half","title":"Spin locks in linux"},{"location":"tutorials/spin-locks-in-linux/#spin-locks-in-linux","text":"SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM A spinlock is a mutual exclusion device that can have only two values: \"locked\" and \"unlocked.\" It is usually implemented as a single bit in an integer value. Code wishing to take out a particular lock tests the relevant bit. If the lock is available, the \"locked\" bit is set and the code continues into the critical section. If, instead, the lock has been taken by somebody else, the code goes into a tight loop where it repeatedly checks the lock until it becomes available. This loop is the \"spin\" part of a spinlock. Any time kernel code holds a spinlock, preemption is disabled on the relevant processor. Even uni-processor systems must disable preemption in this way to avoid race conditions. Below are the variants of spin locks: spin_lock() --- this acquires the spin lock, disables the preemption, but interrupts are enabled. --- disables preemption on local CPU --- acquire spin lock Usage: This is used when we do not share the critical section with interrupt handlers (i.e. only in process context). spin_lock_irq() --- this acquires the spin lock after disabling the preemption & interrupts on local CPU --- disable interrupt on local CPU --- disables preemption on local CPU --- acquire spin lock Usage: This is used when we share the critical section with Interrupt Service Routine. spin_lock_irqsave() --- same as spin_lock_irq() but saves the CPSR register in a local variable, so that we can restore it later on. --- save the CPSR into local variable (i.e. flag) --- disable interrupt on local CPU --- disables preemption on local CPU --- acquire spin lock Usage: This again is used when we share critical section with Interrupt Service Routine spin_lock_bh() --- disables software interrupts before taking the lock, but leaves hardware interrupts enabled. --- disable bottom-half on local CPU --- disables preemption on local CPU --- acquire spin lock Usage: This is used when we share the critical section with bottom half","title":"Spin Locks in Linux"},{"location":"tutorials/story-of-a-boot-loader/","text":"Story Of A Boot Loader SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM \"A bootstrap is a small strap at the back of a leather boot that enables you to pull the entire boot on.\" Boot-loader's task is to load the kernel into RAM and pass control to kernel. In computers bootstrap is used to load a program into a computer using a much smaller initial program to load in the desired program (which is usually an operating system) In today's world meaning of boot-loader is more than just loading the operating system (kernel), it provides options to validate/test the hardware present on the machine. As well provide ways to debug you program. Most of the boot-loader support GDB debugging. Boot-loader program very from hardware to hardware, you should be aware about the assembly language/ instruction for the target platform. If we talk about the x86 machines, BIOS is the first program that runs when machine starts, and later it loads the Windows operating system. If you ever get a change to enter into the BIOS program, you will get lots of features like enable/disable the hardware properties. Now let's talk about the embedded systems, we have mindset that embedded system have very limited memory. But if we look around we find that's not valid now a days, we have enough memory, apart from few embedded systems. So memory is not a constraint, but still we make sure that our boot-loader program takes minimum time to boot up. U-boot is quite famous bootloader; it was initially developed by Denx for PowerPC. Other bootloaders derived from the U-boot are PPCBoot, RedBoot, Barebox. Barebox is called the U-boot version 2, it takes the advantage of linux config file system. ARM Boot-loaders: In arm, boot-loaders are divided into three stages: 1) Boot-ROM : A simple boot-loader, which resides into ROM, and its duty is to initialize the SRAM and loads the first stage boot-loader into SRAM. SRAM is also a small memory. 2) First stage boot-loader : A first stage boot-loader runs itself from SRAM and its primary responsibility is to initialize the DRAM and loads the secondary boot-loader and pass control to it. 3) Second stage boot-loader : This boot-loader is the full-fledged boot-loader, which provides different options to debug/run the program. It does some set of basic initialization again and passes the control to the kernel. 4) Operating System : Once kernel gets the control, it decompresses itself and does initializations of all the peripherals. At last you get the prompt, now you can execute you favorite program. Boot-loader's Initializations Steps: In brief the following are the generic things that boot-loader does 1. Disable all interrupts. 2. Copy any initialized data from ROM to RAM. 3. Zero the uninitialized data area. 4. Allocate space for and initialize the stack. 5. Initialize the processor's stack pointer. 6. Create and initialize the heap. 7. Execute the initializers for all global data 8. Enable interrupts. 9. Call main loop. Optimizations: As boot-loader should take minimal time to boot, it must be optimized for the performance. The following are the things that should be taken care while writing code for the boot-loader. \u00b7 Use inline functions whenever possible? it increases code size but saves u the overhead of stack push & pop operations \u00b7 Code all critical / frequently used code in assembly \u00b7 Store frequently used variables in register \u00b7 Use global variables it saves you push/pop stack operation during function call. \u00b7 Don't use floating point calculations / variables. \u00b7 Enable GCC Optimization. o -O1 = With this option the resulting executable should be smaller and faster than with -O0 o -O2 = This option is generally the best choice for deployment of a program o -O3 = This option may increase the speed of the resulting executable, but can also increase its size o -Os = This option selects optimizations which reduce the size of an executable. Refer the below link for the list and comparison of all the boot-loaders available in the market. https://en.wikipedia.org/wiki/Comparison_of_boot_loaders Conclusion: It's really crucial decision to choose the right boot-loader for your platform. Generally the trade-off between features and performance, so first list all the features required for the platform. Latter choose the best available options from the list of the boot-loader's available in the market. If performance is the major concern for you platform, I suggest write your own piece of code which does the minimum set of initializations, but it requires lots of time and effort to development. Best approach is to pick an open source boot-loader from the market, and customize it as per your needs. Modern boot-loaders like u-boot gives flexibility to configure the features required as per your needs. Summary : Boot-loader is a program whose primary job is to load the kernel and pass control to it. Additionally it provides features to test and debug the present hardware. Arm supports three stage boot-loaders which gives additional security from the hackers. Primary objective while writing boot-loader is to make it optimized for performance. References : 1. http://en.wikipedia.org/wiki/Booting 2. http://searchcio-midmarket.techtarget.com/definition/bootstrap 3. http://www.denx.de/wiki/U-Boot","title":"Story of a boot loader"},{"location":"tutorials/story-of-a-boot-loader/#story-of-a-boot-loader","text":"SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM \"A bootstrap is a small strap at the back of a leather boot that enables you to pull the entire boot on.\" Boot-loader's task is to load the kernel into RAM and pass control to kernel. In computers bootstrap is used to load a program into a computer using a much smaller initial program to load in the desired program (which is usually an operating system) In today's world meaning of boot-loader is more than just loading the operating system (kernel), it provides options to validate/test the hardware present on the machine. As well provide ways to debug you program. Most of the boot-loader support GDB debugging. Boot-loader program very from hardware to hardware, you should be aware about the assembly language/ instruction for the target platform. If we talk about the x86 machines, BIOS is the first program that runs when machine starts, and later it loads the Windows operating system. If you ever get a change to enter into the BIOS program, you will get lots of features like enable/disable the hardware properties. Now let's talk about the embedded systems, we have mindset that embedded system have very limited memory. But if we look around we find that's not valid now a days, we have enough memory, apart from few embedded systems. So memory is not a constraint, but still we make sure that our boot-loader program takes minimum time to boot up. U-boot is quite famous bootloader; it was initially developed by Denx for PowerPC. Other bootloaders derived from the U-boot are PPCBoot, RedBoot, Barebox. Barebox is called the U-boot version 2, it takes the advantage of linux config file system.","title":"Story Of A Boot Loader"},{"location":"tutorials/story-of-a-boot-loader/#arm-boot-loaders","text":"In arm, boot-loaders are divided into three stages: 1) Boot-ROM : A simple boot-loader, which resides into ROM, and its duty is to initialize the SRAM and loads the first stage boot-loader into SRAM. SRAM is also a small memory. 2) First stage boot-loader : A first stage boot-loader runs itself from SRAM and its primary responsibility is to initialize the DRAM and loads the secondary boot-loader and pass control to it. 3) Second stage boot-loader : This boot-loader is the full-fledged boot-loader, which provides different options to debug/run the program. It does some set of basic initialization again and passes the control to the kernel. 4) Operating System : Once kernel gets the control, it decompresses itself and does initializations of all the peripherals. At last you get the prompt, now you can execute you favorite program.","title":"ARM Boot-loaders:"},{"location":"tutorials/story-of-a-boot-loader/#boot-loaders-initializations-steps","text":"In brief the following are the generic things that boot-loader does 1. Disable all interrupts. 2. Copy any initialized data from ROM to RAM. 3. Zero the uninitialized data area. 4. Allocate space for and initialize the stack. 5. Initialize the processor's stack pointer. 6. Create and initialize the heap. 7. Execute the initializers for all global data 8. Enable interrupts. 9. Call main loop.","title":"Boot-loader's Initializations Steps:"},{"location":"tutorials/story-of-a-boot-loader/#optimizations","text":"As boot-loader should take minimal time to boot, it must be optimized for the performance. The following are the things that should be taken care while writing code for the boot-loader. \u00b7 Use inline functions whenever possible? it increases code size but saves u the overhead of stack push & pop operations \u00b7 Code all critical / frequently used code in assembly \u00b7 Store frequently used variables in register \u00b7 Use global variables it saves you push/pop stack operation during function call. \u00b7 Don't use floating point calculations / variables. \u00b7 Enable GCC Optimization. o -O1 = With this option the resulting executable should be smaller and faster than with -O0 o -O2 = This option is generally the best choice for deployment of a program o -O3 = This option may increase the speed of the resulting executable, but can also increase its size o -Os = This option selects optimizations which reduce the size of an executable. Refer the below link for the list and comparison of all the boot-loaders available in the market. https://en.wikipedia.org/wiki/Comparison_of_boot_loaders","title":"Optimizations:"},{"location":"tutorials/story-of-a-boot-loader/#conclusion","text":"It's really crucial decision to choose the right boot-loader for your platform. Generally the trade-off between features and performance, so first list all the features required for the platform. Latter choose the best available options from the list of the boot-loader's available in the market. If performance is the major concern for you platform, I suggest write your own piece of code which does the minimum set of initializations, but it requires lots of time and effort to development. Best approach is to pick an open source boot-loader from the market, and customize it as per your needs. Modern boot-loaders like u-boot gives flexibility to configure the features required as per your needs.","title":"Conclusion:"},{"location":"tutorials/story-of-a-boot-loader/#summary","text":"Boot-loader is a program whose primary job is to load the kernel and pass control to it. Additionally it provides features to test and debug the present hardware. Arm supports three stage boot-loaders which gives additional security from the hackers. Primary objective while writing boot-loader is to make it optimized for performance.","title":"Summary:"},{"location":"tutorials/story-of-a-boot-loader/#references","text":"1. http://en.wikipedia.org/wiki/Booting 2. http://searchcio-midmarket.techtarget.com/definition/bootstrap 3. http://www.denx.de/wiki/U-Boot","title":"References:"},{"location":"tutorials/what-makes-a-real-rtos/","text":"What makes a real RTOS? SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM Definition of RTOS: RTOS stands for Real Time Operating System. The real definition of RTOS is: \"RTOS is an operating system which perform the task in given scheduled time\" In other words \" RTOS schedules the task in definite time \" Earlier RTOS is requirement in Medical industry, Military & Aerospace industry, but in today's world RTOS becomes the requirement for consumer industry as well. Types of RTOS: RTOS is further divided into two categories Hard Real Time Operating System (RTOS) Soft Real Time Operating System (RTOS) Hard Real Time Operating System: It's clear from the name Hard-RTOS schedules the task with more accuracy; slight deviation from the schedule is not acceptable. System failure will occur if you miss the deadline. Soft Real Time Operating System: On the other hand Soft-RTOS provides the flexibility, it can deviate from the schedule. So it's not recommended for crucial application where life threat is there. Scheduler plays a crucial role when RTOS comes into picture; its prime responsibility is to schedule the entire task in defined time. Scheduler must be efficient enough schedule each task in predefined time; the key rule here is scheduler should not have any indefinite parameters. Indefinite parameters make scheduler difficult to calculate the accurate time to execute the process, and the system to deviate from the scheduled time. RTOS Criteria: The following are the parameters that make RTOS to deviate from the schedule Context Switching time Interrupt latencies Context Switching time Context-switching time is the time taken by the scheduler to execute the next process in the scheduling queue. Context switching may occur due to timeout occurs if Round Robin scheduling, higher priority process comes, and if interrupt comes from the hardware. During context switching the scheduler saves the current set of registers into the memory (generally stack) and loads the next process context from memory. Scheduler itself takes few cycles to change the context, this time should be minimal. In case if not possible to minimize the context-switching time, make it definite. If context- switching time is indefinite, may result in deviate you operating system from RTOS concept. Interrupt latencies Second parameter is Interrupt latency, it's the time between the when hardware generate an interrupt and corresponding hardware interrupt handler first line gets executed. So operating system itself takes some time to identify from which device the interrupt has come, and call the registered interrupt handler for the hardware. Again this time should be DEFINITE and optimized. RTOS Operating Systems: LynxOS, QNX, VxWorks, RT Linux, Windows CE are famous RTOS in the market. Further Reading: 1. http://en.wikipedia.org/wiki/RTOS 2. http://www.qnx.com/developers/articles/article_298_1.html 3. http://www.barrgroup.com/Embedded-Systems/How-To/RTOS-Selectio","title":"What makes a real rtos"},{"location":"tutorials/what-makes-a-real-rtos/#what-makes-a-real-rtos","text":"SEPTEMBER 28, 2018 \\~ ADMIN\\@EMBEDDEDPROGRAMS.COM Definition of RTOS: RTOS stands for Real Time Operating System. The real definition of RTOS is: \"RTOS is an operating system which perform the task in given scheduled time\" In other words \" RTOS schedules the task in definite time \" Earlier RTOS is requirement in Medical industry, Military & Aerospace industry, but in today's world RTOS becomes the requirement for consumer industry as well. Types of RTOS: RTOS is further divided into two categories Hard Real Time Operating System (RTOS) Soft Real Time Operating System (RTOS)","title":"What makes a real RTOS?"},{"location":"tutorials/what-makes-a-real-rtos/#hard-real-time-operating-system","text":"It's clear from the name Hard-RTOS schedules the task with more accuracy; slight deviation from the schedule is not acceptable. System failure will occur if you miss the deadline.","title":"Hard Real Time Operating System:"},{"location":"tutorials/what-makes-a-real-rtos/#soft-real-time-operating-system","text":"On the other hand Soft-RTOS provides the flexibility, it can deviate from the schedule. So it's not recommended for crucial application where life threat is there. Scheduler plays a crucial role when RTOS comes into picture; its prime responsibility is to schedule the entire task in defined time. Scheduler must be efficient enough schedule each task in predefined time; the key rule here is scheduler should not have any indefinite parameters. Indefinite parameters make scheduler difficult to calculate the accurate time to execute the process, and the system to deviate from the scheduled time.","title":"Soft Real Time Operating System:"},{"location":"tutorials/what-makes-a-real-rtos/#rtos-criteria","text":"The following are the parameters that make RTOS to deviate from the schedule Context Switching time Interrupt latencies","title":"RTOS Criteria:"},{"location":"tutorials/what-makes-a-real-rtos/#context-switching-time","text":"Context-switching time is the time taken by the scheduler to execute the next process in the scheduling queue. Context switching may occur due to timeout occurs if Round Robin scheduling, higher priority process comes, and if interrupt comes from the hardware. During context switching the scheduler saves the current set of registers into the memory (generally stack) and loads the next process context from memory. Scheduler itself takes few cycles to change the context, this time should be minimal. In case if not possible to minimize the context-switching time, make it definite. If context- switching time is indefinite, may result in deviate you operating system from RTOS concept.","title":"Context Switching time"},{"location":"tutorials/what-makes-a-real-rtos/#interrupt-latencies","text":"Second parameter is Interrupt latency, it's the time between the when hardware generate an interrupt and corresponding hardware interrupt handler first line gets executed. So operating system itself takes some time to identify from which device the interrupt has come, and call the registered interrupt handler for the hardware. Again this time should be DEFINITE and optimized.","title":"Interrupt latencies"},{"location":"tutorials/what-makes-a-real-rtos/#rtos-operating-systems","text":"LynxOS, QNX, VxWorks, RT Linux, Windows CE are famous RTOS in the market.","title":"RTOS Operating Systems:"},{"location":"tutorials/what-makes-a-real-rtos/#further-reading","text":"1. http://en.wikipedia.org/wiki/RTOS 2. http://www.qnx.com/developers/articles/article_298_1.html 3. http://www.barrgroup.com/Embedded-Systems/How-To/RTOS-Selectio","title":"Further Reading:"}]}